## 目录

[TOC]



## Java基础

### 1、什么是 Java 中的不可变类？

被final关键字修饰的类是不可变类，不可变类无法被继承，成员变量也无法被修改



### 2、Java 中的序列化和反序列化是什么？

序列化即将Java对象转化为字节流文件便于实现持久化。反序列化即将字节流文件转化为Java对象，通常通过Serializable接口实现



### 3、你认为 Java 的优势是什么？

1. **面向对象的编程语言**
2. **JVM跨平台运行**
3. **丰富的第三方库、生态**
4. 垃圾回收机制



### *4、Java 中的参数传递是按值还是按引用？

按值传递。无论是基本数据类型还是饮引用数据类型，都是按值传递。

引用类型 作为参数时，传递的是引用地址的副本，也就是传递的地址的拷贝值



### 5、Java 方法重载和方法重写之间的区别是什么？

重载是指相同的方法名不同的参数的不同调用

重新是指在父类的继承/接口的实现时，对类的扩展时，对继承/实现的方法进行重写



### *6、什么是 Java 内部类？它有什么作用？

内部类指的是**定义在类的内部的类**。内部类分为<u>成员、局部、静态、匿名</u>内部类。

使用内部类将具有相同业务逻辑的代码定义在一个类的内部可以**提高代码的内聚性，简化代码结构，减少代码的冗余**



### ***7、JDK8 有哪些新特性(7个)？**

- 用**元空间**代替了永久代：HotSpot虚拟机中永久代回收效率太低
- 引入了**Lamda表达式**：一种匿名函数，可以像参数一样传递，使代码更简洁更灵活
- 引入了**新的日期类**：新的日期类不可变且线程安全
- 提供**接口默认方法 、静态方法**：将相关方法内聚，不必创建新的对象
- 新增**Stream流式接口**：便于数据处理，链式操作并行处理 
- 增加了**Optional类**：解决NullPointerException问题
- **CompletableFuture类**：提供了新的异步编程模型



### 8、Java 中 String、StringBuffer 和 StringBuilder 的区别是什么？

String被final关键字修饰不可被继承不可被修改

**StringBuffer**可以被修改，可变的可以对字符串进行增删改操作，**线程安全**。**适合多线程**

**StringBuilder**也可以被修改，**线程不安全，因此性能比StringBuffer好。适合单线程**



### 9、Java 的 StringBuilder 是怎么实现的？

- StringBuilder底层使用**字符数组实现**
- 内部提供了append、insert、replace等方法用于修改字符数组，而不再重新new一个String对象
  在对StringBuilder进行操作时，首先会判断操作的字符所占用的空间，再判断数组是否能容纳操作的字符或者是否能缩容。最后在将操作的字符扩容加入/删去缩容
- 但字符数组的空间不足时，字符数组以原来的**2倍扩容**。





### 10、JDK 和 JRE 有什么区别？

JDK是指**Java开发套件，包含了JRE、以及编译器、打包工具、调试工具**等用于开发调试Java应用

JRE是指**Java运行环境，包含了JVM、核心类库、配置文件、库文件**等



### 11、你使用过哪些 JDK 提供的工具？

JDK提供的主要工具：

- **javac：java编译器。将.java文件编译成字节码文件.class格式**
- **java：java应用程序启动器，用于运行Java程序**
- **javadoc：生成HTML格式的api文档**
- jdb：Java调试工具
- **jar：用于创建和管理jar包文件**

性能监控分析：

- jmap：内存映射工具，内存泄漏分析和垃圾回收优化
- jhat：堆分析工具，帮助开发者了解内存使用情况



### **12、Java 中 hashCode 和 equals 方法是什么？它们与 == 操作符有什么区别？**

- hashconde是在散列结构中，用于比较两个元素是否相等。本质上是比较两个元素的哈希值是否相等，通过比较hash值，快速确认两个值是否相等
- **equals方法：比内容**。是比较两个值/对象中的属性是否相等。如果比较的是对象，通常需要重写equals方法
- **==：比地址**。比较的是两个引用是否指向同一块地址空间。如果是基础数据类型，比较的是他们的值



### 13、Java 中的 hashCode 和 equals 方法之间有什么关系？

equals的默认实现是==比较运算法，hashcode是返回对象的哈希值，可以通过比较hash值判断两个对象是否相等，相同的对象返回的hash值必须是相等的。

- **如果两个对象的equals运算的结果是相等的，那么他们hashcode比较的结果必定是相等的。**
- **hashcode比较结果相等，equals方法比较的结果却不一定相等**



### *14、什么是 Java 的 SPI（Service Provider Interface）机制？

一种**为服务框架提供服务实现的机制**。它**允许框架在运行时动态的发现服务的实现**，以便模块化设计

核心思想是通过配置文件声明服务提供者的实现，Java运行时**通过配置文件找到并加载相应的服务实现**



### 15、Java泛型的作用是什么？

泛型的指定通过<u>**在编译时检查类型安全**，**避免**在运行时出现**类型转换错误**。</u>

- 类型安全：类型安全检查**确保**在代码执行时**不会出现类型不匹配**的问题。
- 代码重用：泛型可以使不同的数据类型使用同一段相同逻辑的代码
- 避免了显示类型转换：在编译时指定了类型，不必在运行时进行显示类型转换，减少了性能开销



### 16、Java 泛型擦除是什么？

<u>编译时清除泛型信息，保证兼容性。Java1.4之前没有引入泛型</u>

Java代码在**编译时对所有泛型信息进行删除**的过程。确保与java1.4版本以及之前的版本**保持向下兼容**。Java1.4之前没有引入泛型。在泛型擦除后编译器会选择合适的类型替换泛型类型参数。使用对象的上限替代掉类型参数。**默认采用Object**类型作为替代。或者**在插入类型元素时对元素类型进行检查转换**



### 17、什么是 Java 泛型的上下界限定符？

上下界限定符主要是用于**对泛型的类型参数进行范围限制**。

- **上界限定符<？extends T>**：表示泛型参数必须是**T/T的子类**。**通常用于读取操作**。例如上界限定符Number类型，可使用Integer、Double参数类型
- **下界限定符<？super T>**：表示泛型参数必须是**T/T的父类**。**通常用于写入操作**。确保能够正确将对象插入至集合中



### ***18、Java 中的浅拷贝和深拷贝有什么区别？**

- 浅拷贝：**创建一个对象但对对象内的引用类型只会复制对象地址**，相当于创建对象后只复制了对象地址引用，并没有真正的将地址内的内容拷贝过来，**对浅拷贝对象的修改会影响到原来的被拷贝对象**。Java中clone()默认实现浅拷贝操作
- 深拷贝：则不仅复制了拷贝的对象，还将**对象中的所有引用都我试试现在递归的复制了一份到新的地址空间**，**对深拷贝对象的修改不会影响到原来的被拷贝对象**。实现深拷贝有两种方式：一种是通过**递归调用clone()方法**，另一种是通过序列化和反序列化

- 引用拷贝：复制的只是目标的引用地址。引用变量的=赋值就是引用拷贝



### 18-1、怎么实现深拷贝？

深拷贝有两种方式：

1. 一种是通过**递归调用clone()方法**，
2. 另一种是通过序列化和反序列化



### 19、什么是 Java 的 Integer 缓存池？

<u>对Integer型数据缓存，使用时不用再创建对象装箱，速度更快</u>

Java包装类型有自动拆箱/装箱机制。当我们每次**使用Integer类型时都需要装箱拆箱会造成较多的性能浪费**。所以java**为了提升性能提供了Integer缓存池**，缓冲池会将常用的int值(-128~127)缓存在缓存池中，当我们需要这些值时，就不必临时创建Integer对象，**提高性能。还能节约内存**，因为**减少了对象的频繁创建可以降低垃圾回收机制的负担**



### 20、什么是 Java 的 BigDecimal？

Java中**用于高精度计算的类**，BigDecimal类具备**高精度**、**不可变性**、**丰富的计算功能**等特点，**提供了对浮点数和定点数的精确控制**。常用于金融和科学计算等需要高精度计算的领域



### 21、为什么在 Java 中编写代码时会遇到乱码问题？

因为在**编码时字符集与解码时使用的字符集不一致**导致的。常见的有以下情况：

- 默认编码设置问题：Java默认采用的操作系统的字符集，不同操作系统采用字符集不一致
- 流处理中编码设置问题：流处理时没有指定字符集采用了默认编码。
- 数据库乱码：数据库字符集与应用的字符集不一致



### 22、为什么 JDK 9 中将 String 的 char 数组改为 byte 数组？

<u>原本是UTF-16占两个字节，改成了coder编码改byte占一个字节，节约内存</u>

JDK9之前虽然是**基于char[]数组实现的，但内部采用的是UTF-16编码**，每个字符需要占用两个字节。**如果当前字符只需要一个字节的空间就造成了性能浪费**。例如Latin-1z字符。

**JDK9之后，字符串引入了coder变量标识编码方式**，当字符串只包含存在处于Latin-1范围之内字符时，使用单字节编码，**节省内存**。否则使用UTF-16编码。



### 23、栈和队列在 Java 中的区别是什么？

- **栈只允许在一端进行数据操作**，即入栈和出栈。遵循**先进后出**原则。Java中Stack类实现了这个数据结构。通常用于**函数调用，表达式求值，回溯算法（DFS）**
- **队列允许一端插入，另一端取出**。即入队和出队。遵循**先进先出**原则。Java中Queue类实现了这个数据结构。**通常用于任务调度、资源管理、数据流处理（BFS）**



### 24、Java 的 Optional 类是什么？它有什么用？

<u>**Java8引入的容器类，表示可能为空的值**。**减少出现null的情况**。避免NullPointerException的发生。</u>

Optional类可以包含一个值，也可以为空。分别表示值存在和值不存在。**使用Optional代替null避免了使用Null表示值不存在**



### 25、Java 的 I/O 流是什么？

<u>**指输入输出流，分别有输入流、输出流、字节流、字符流。**</u>

I/O流是指Java处理数据的输入/输出的相关功能。包括了一些处理数据的类库和基本操作。可以读取网络/硬盘中的数据，也可以向目标位置写入数据。

其中主要分为**字节流**和**字符流**。

**字节流：**相应的类通常以InputStream和OutputStream为后缀。处理8位的字节数据，常见的有图片、视频、文件等。**例如FileInputStream、BufferedInputStream、DataInputStream等**

**字符流**：则用常以Reader和Writer为后缀。处理16位的字符数据，通常用于处理文本信息和文本文件。**例如FileReader、BufferedReader、DataReader等**

还有对基础流的增强包装**缓冲流，缓冲流的内置缓冲区大大提高了I/O的性能。**

 

### 26、Java 中的访问修饰符有哪些？

public 公开、protected 保护、default 默认、private 私有



### 27、Java 中静态方法和实例方法的区别是什么？

<u>**静态方法属于类，实例方法属于对象实例**</u>

静态方法是属于类的而不是属于类的实例的。

静态方法可以直接通过类名调用。

随着类的加载而加载，类的卸载而消失



### 28、什么是 Java 中的双亲委派模型？

<u>Java的**类加载机制。类加载器在加载时会将类的加载委派给该类的父类加载器**</u>

类加载器在加载某个类时，会将**类的加载委派给该类的父类加载器**。父类再将加载委托给父类加载器直至根加载器。父类加载器无法加载时，才由当前类自行加载。



### 29、Java 和 Go 的区别

**设计理念**：

- Java注重面向对象编程**，具有封装继承多态等特性**。同时Java程序是运行在JVM之上的，实现了**一次编写，到处运行的**跨平台特性。Java设计目标是**提供一个灵活可扩展的通用编程平台。**
- Go注重**面向系统级编程和并发处理**。强调**简单的语法和快速的编译**，注重简洁和高效的编程语言。设计目标是**提高开发者的生产力。**

**并发模型**：

- Java的并发模型依靠的是**Thread类和Executor框架管理**并发任务。并发编程需要**显式的创建、同步、资源共享**
- Go是**基于Goroutine的**，比操作系统线程**更轻量级的线程**。**简化**了**线程通信和同步**

**内存管理**：

- Java的垃圾回收机制拥有多种GC算法，可根据不同场景选择不同的方案。
- Go同样具有垃圾回收机制，但**设计上更简洁，专注减少GC开销，**适合处理大量并发请求。

**应用场景**：

- Java常用于**企业系统开发**、Web开发、以及安卓开发等业务开发。具有丰富的三方库提供完整的企业开发生态。
- Go一**般用于云计算等高性能服务端开发**。Go的简洁设计为高性能并发处理提供了更好的表现力



### 30、Java Object 类中有什么方法，有什么作用？

- equals()：比较两个对象是否相等
- hashCode方法：返回对象的哈希码。
- toString方法：返回对象的字符串表示
- getClass方法：返回运行时的Class类对象，final修饰，不能被重写
- notify/notifyAll方法：唤醒等待的 (所有) 线程，需要在同步块/同步方法中调用。
- wait方法：使当前线程等待
- clone方法：创建对象并返回当前对象的副本。默认实现浅拷贝（基本数据类型深拷贝，引用数据类型只拷贝地址）



## 集合框架

### 1、Java 中 for 循环与 foreach 循环的区别是什么？

- for语句是传统的循环语句，可以控制循环的初始化、循环条件、步进迭代
- f**oreach是Java5引入的简化循环结构**，用于遍历数组或者实现了Iterable接口的集合。优点如下：
  - 语法更简洁。提高可读可维护性
  - 只读访问。
  - 不可修改集合结构。保证集合内部安全

### 2、什么是 Java 中的迭代器（Iterator）？

用于遍历集合中元素的对象，提供了一种统一的方法来访问集合中的元素，而**不需要关注实现具体代码**，就像一个指针一样，可以依次指向集合中的每个元素



## 面向对象

### 1、Java 中的基本数据类型有哪些？

有byte、short、int、long、float、double、char、boolean

占用内存分别是：1、2、4、8、4、8、1、1



### 2、Java 中包装类型和基本类型的区别是什么？



Java提供了8种基本数据类型，分别是byte、int、short、long、float、double、char、boolean。每一种基本数据类型都提供了其包装类。主要原因是因为**<u>Java作为面向对象编程语言，经常需要使用Object引用而不是基本数据类型。Java提供了自动拆箱装箱机制，便于包装类型的使用</u>**。区别在于

- **性能不同**：包装类型需要拆箱装箱需要性能消耗
- **默认值不同**：包装类型的默认值为null，基本数据类型可以是0/false
- **创建方式不同**：基本数据类型可以用=赋值，包装类型需要使用new关键字
- **存储方式不同**：基本数据类型存储在栈中，包装类型存储在堆中
- **比较方式不同**：基本数据类型比较运算符比较值的大小，而包装类型比较的是对象的地址是否相同



### 3、什么是 Java 中的自动装箱和拆箱？

自动装箱：是Java编译器自动将基础数据类型转换成包装数据类型。

自动拆箱：是Java编译器自动将包装数据类型转换成包装数据类型。

底层是通过调用**包装类型的valueof方法和xxxValue方法**实现的



### 4、什么是 Java 中的继承机制？

面向对象的核心机制之一。类可以通过extend关键字继承被继承类中的一些成员方法和成员变量。

子类通过继承可以提高代码的复用、使代码更易维护。缺点就是使得代码紧耦合，父类的修改会影响到子类



### 5、什么是 Java 的封装特性？

面向对象的核心机制之一。类将成员变量和成员方法封装在类的内部，**仅通过提供公共的接口供外部访问**。主要**目的是隐藏类的内部具体实现**，**只暴露必要的功能。从而保护类的完整性和减少系统的复杂性。**



### *6、什么是 Java 的多态特性？

**同一个父类引用/接口**指向不同的实例对象，不同的子类实例在运行时调用相同父类或接口方法**展现出不同的行为**叫多态。



### 7、使用 new String("str") 语句在 Java 中会创建多少个对象？

**一个或者两个**。需要根据常量池中是否存在的引用的不同情况而定。在JVM中存在着一个**字符串池，其中保存着很多String对象，并且可以被共享使用**，因此它提高了效率

主要分为两种情况：

- **常量池中没有引用**：Java会**在堆创建两个对象**，其中一个字符串对象创建在常量池中，另一个复制常量池中的对象交给String引用
- **常量池中有引用**：则**只会在堆中创建一个字符串对象引用**

将`String s = new String("abc")`拆开看其中`String s =`只是声明了一个引用变量。`new String("abc")`。才真正的创建了一个String对象。而String的构造方法其中的参数也是"abc"。本质上还是将常量池中“abc”对象传入构造方法内。

另外String a="ab"+"cd"，则是创建了三个对象。因为String是被final修饰的，无法修改，只能通过重新创建对象合并字符串。



### *8、为什么 Java 不支持多重继承？

因为多重继承**会出现菱形继承问题**，导致子子类继承来自同一个父类的子类对象时相同的方法**会产生歧义**，程序无法区分调用的哪一个方法。

至于为什么可以接口多实现，在Java8之前接口的实现必须重写接口方法，Java8之后有了默认方法也要求必须重写



### 9、接口和抽象类有什么区别？

首先是设计理念上的不同：

- 接口类的设计思想是**自上而下**的。在设计初期先根据某一行为定义通用的方法，在接口的实现时重写定义的方法
- 抽象类的是**自下而上**的。先有了子类的实现，再对子类中相同的方法和共性进行抽象

继承方式：

- 接口类可以多实现，但必须重写默认方法
- 抽象类不可多继承，避免出现菱形继承的问题

内部的方法类型不同：

- **接口类中的所有方法都是public、static、final修饰的**
- 抽象类中可以包含构造函数，成员变量可以有不同的访问修饰符



### 10、Java 的类加载过程是怎样的？

主要分为三个过程：加载、连接（验证—准备—解析）、初始化

- **加载**：将**二进制文件读取到内存中**，**生成Class对象**
- **连接**：
  - **验证**：验证二进制文件**是否符合一定格式，规范以及是否符合当前JVM版本**
  - **准备**：为**静态变量**，**分配内存空间**
  - **解析**：将常量池中的**符号引用转化为直接引用**
- **初始化**：**执行静态代码块，为静态变量赋值**



## 异常

### *1、Java 中 Exception 和 Error 有什么区别？

Exception是指异常，异常分为运行时异常和编译时异常，异常可以被程序捕获的并处理恢复。常见的有IO异常、SQL异常、NullPoint异常、IndexOutOfBounds异常

Error指错误，一般指系统级的发生错误而终止。无法被捕获处理，发生错误程序会被终止。通常有内存耗尽、栈溢出



### 2、Java 中 final、finally 和 finalize 各有什么区别？

- final关键字通常用于修饰常量。可以用于类、方法、变量上。

  - 被final修饰的类不可被继承
  - 被final修饰的方法不可被重写
  - 被final修饰的变量不可被修改

  通常用于设计不可变的类。确保类的安全性

- finally通常与try-catch语句一同使用。在执行try-catch语句块后，如果使用了finally代码块，确保异常发生后代码块一定会执行。通常在finally语句块中编写释放资源的相关代码。



### 3、Java 运行时异常和编译时异常之间的区别是什么？

区别主要在：**发生时机、捕获/处理方式、设计思想**

发生时机：

- **编译时异常发生在源文件编译阶段**，编译器会检查这些异常，如果不处理。程序则无法通过编译。
- **运行时异常发生在程序运行阶段**，程序员可以选择是否处理他们。通常是**程序逻辑错误导致的**

捕获/处理方式：

- 编译时异常：**需要在代码中显式处理**。要使用try-catch/throws关键字声明异常
- 运行时异常：**可以不用显式处理**，使用Try-catch捕获处理**或让程序终止时JVM抛出。**

设计思想：

- **编译异常一般是由外部因素导致的**，例如文件IO、数据库连接。**开发者无法预测，需要编译器强制要求处理**
- 运行异常是由**代码逻辑错误/漏洞引发的**，是程序**内部问题。可以在调试阶段发现**



## 并发和多线程

### 1、Java 中 wait() 和 sleep() 的区别？

都是**用于暂停线程的操作**。

首先，使用的要求不同：

- **wait方法必须在同步块/同步方法内调用**。**否则会抛出异常**。wait依**赖对象锁**来管理线程的等待和唤醒机制。**调用后**线程**释放对象锁**，进入等待状态。
- **sleep方法可以在任何上下文调用**，不需要获取对象锁。调用后线程休眠不会释放任何锁

所属类不同：

- **wait方法**所属**Object类**
- **sleep方法**所属类**Thread类**

恢复方式不同

- **wait方法**暂停的线程需要用**notify方法/notifyall方法唤醒**，或者**使用超时函数唤醒**
- **sleep方法**会在**指定的时间后自动恢复**运行。或者通过**抛出InterruptedException恢复**

用途不同

- **wait**方法常用于**线程通信**，通过notify方法**协调线程工作**
- **sleep**方法用于使线程暂停一会。**模拟延时/控制执行频率**



### 2、如果一个线程在 Java 中被两次调用 start() 方法，会发生什么？

抛出**非法线程状态异常**。

会出现**illegalThreadStateException**异常。因为**一个线程只能被启动一次。一旦被启动，则无法回到初始状态**。



### 3、Java中创建线程的方法有哪些？

- 继承Thread类（本质上是实现Runnable接口）
- 实现Runnable接口
- 实现Callable接口（有返回值时用）



### 4、线程池有哪些核心参数？

- 核心线程池数
- 最大线程池数
- 工作队列
- 多余线程存活时间
- 拒绝策略
- 单位时间



### **5、什么是线程安全？怎么保证线程安全？**

在多线程的情况下，保证代码和数据的正确和一致，不会因为多个线程对数据的处理而导致数据的不一致。

<u>使用锁机制、原子操作、线程安全的集合类</u>



### 6、Java中有哪些集合的类是线程安全的？ArrayList是线程安全吗？

Vector数组、Hashtable、CurrentHashMap

ArrayList不安全



### 7、进程和线程的区别？为什么说线程切换的开销比进程的切换开销小？

**进程**是**资源分配**的基本单位，**线程**是**系统执行**的基本单位，进程由多个线程组成。进程内的线程互相共享资源

- 线程上下文比较小，切换时性能开销小

- 线程在进程内的资源是共享的
- 线程属于同一个进程，权限分配的开销也小





### <u>8、并发编程解释volatile关键字的作用</u>

volatile用于修饰变量，它有**内存可见性、禁止指令重排序**的特点

- **内存可见性：**线程修改该变量的值会在**主内存**中始终保持一致，并且其他线程立即可见
- **禁止指令重排序：**JVM虚拟机优化会改变指令顺序，对该变量操作的指令不会重新排序。

常用于**状态标志量、双重校验锁**





## 反射

### 1、什么是 Java 中的动态代理？

**动态代理**是Java的一种**允许在程序运行时创建代理对象的机制**。程序不需要在编译时就确认具体的对象，在运行是决定代理对象的行为。这样使得程序可以在不修改目标对象的情况下对它进行增强/调整修改

动态代理**是Java反射机制的一种应用**

优点：

- 简化代码，减少重复的代码、
- 增强代码的灵活性，在运行时可以动态改变代理对象的行为
- 实现AOP，面向切面编程的基础是动态代理



### 2、JDK 动态代理和 CGLIB 动态代理有什么区别？

- **JDK动态代理是基于接口的**，**要求动态代理的对象一定是有定义接口的**

- **CGLIB是基于字节码生成工具**，**通过继承的方式生成目标类的子类来实现代理类**。需要注意final方法，final修饰的方法不可被继承



### 3、Java 中的注解原理是什么？

**注解本质上是种标记**，通过注解**可以给代码添加元数据信息，被JVM读取**。这些注解可**以标记在类、方法、属性上面**。但这些注解并**不会影响代码的执行逻辑**，我们可以使用工具/框架提供的注解处理器提取注解中的元数据，从而对这些元数据进行处理，可以是编译时/运行时/代码生成时

Java中的元注解有四类：

- @Retention：注解何时生效（编译/运行/源文件）
- @Inherited：注解能否被继承
- @Target：注解的作用目标
- @Document：是否包含在javadoc中



### 4、你使用过 Java 的反射机制吗？如何应用反射？

一般在我们使用的Spring框架中就有应用到反射机制，其中动态代理以及AOP都有用到反射机制。

反射机制是指在程序的运行中，可以**通过反射机制动态的获取类的成员方法和属性变量，以及类的构造方法等**。反射的**核心类是Class类**，每个类都有Class类通过该类可以获取类相关信息。除此之外还有**Method类、Field类**。获取Class对象有四种种方法：

- 类.Class 调用Class对象
- 类.getClass()方法 获取Class对象
- Class.forName(类的全路径)
- 类加载器.loadClass(类全称)







## Java锁

### 1、Java有哪些锁？

synchronized锁

ReentrantLock锁



### 2、什么是乐观锁、悲观锁？两者有什么区别？底层是如何实现的？

- 乐观锁：乐观认为读多写少，默认不加锁。通常在数据库添加flag标识，需要写时，检查flag是否一致，再对操作上锁
- 悲观锁：认为写多， 默认加锁。性能开销较大，安全性较高



### 3、什么是公平锁？什么是非公平锁？它们各有什么优缺点？

- **公平锁**：锁的资源的分配是公平的。优点就是**公平**，缺点**不够灵活**
- **非公平锁**：**随机分配**资源或者**就近分配**。实际用得多，因为灵活分配，**性能比公平锁的效率高不少**。



### <u>4、ReentrantLock和synchronized的区别是什么？5</u>

- 用法：**Re**用于代码块，**sy**用于方法、代码块
- 获取方式：**Re**需要手动获取释放，sy自动
- 锁的类型：**Re**可以是公平/非公平锁，sy是非公平锁
- 响应中断：**Re**可以获取锁并响应中断，sy不能，会死锁
- 底层实现：Re是AQS实现，**sy**是监视器实现

|              | ReentrantLock | synchronized |
| ------------ | ------------- | ------------ |
| **用法**     | 代码块        | 方法、代码块 |
| **获取方式** | 手动          | 自动         |
| **锁的类型** | 公平/非公平锁 | 非公平锁     |
| **响应中断** | 可以          | 不能，会死锁 |
| **底层实现** | AQS           | 监视器       |

*AQS是构造 锁和同步器的框架*



## JVM

### <u>1、JVM描述JVM的内存模型</u>

方法区（元空间）、堆、本地方法栈、虚拟机栈、程序计数器

- **方法区（元空间）：**线程共享。**常量、静态变量、类信息**
- **堆：**所有线程共享。**对象实例**，内存分配和垃圾回收的重点区域
- **本地方法栈：**线程私有，虚拟机使用到的**本地（Native）方法**服务
- **虚拟机栈：**线程私有，存储局部**变量表（各种数据类型）**、**操作数栈**、动态链接、**方法出口**等信息
- **程序计数器：**存储正在执行的虚拟机**指令的地址**。



### <u>2、什么是GC（垃圾回收）</u>

虚拟机在运行时，创建对象需要分配内存空间。内存空间是有限的，当创建的对象不需要时，内存需要得到释放。CG垃圾回收就可以帮助程序员自动释放内存。



### <u>3、常见的GC算法有哪些？4</u>

- **标记清除法**：标记被使用的内存，清理没有被引用的内存。
- **复制算法**：将内存分为两块区域，一次只用一块，将被标记的内存移动到另一块，清空原来那块。
- **标记整理法**：将被标记的内存向一边对齐整理，然后清除另一边内存。
- **分代收集算法**：将内存空间分为新生代、老年代、永生带三块。不同区域使用不同算法，根据对象寿命将它们放在不同的内存中



### <u>4、如何排查和解决JVM内存泄漏问题？</u>

**排查**：**监控内存使用情况**，如果内存使用持续增长，垃圾回收频繁且回收效果不佳，或者出现 `OutOfMemoryError` 异常

**解决**：确保资源在使用后正确关闭，**优化缓存和连接池策略**



### <u>5、如何判断哪些内存需要回收？2</u>

- **可达性分析**：从GC Roots对象开始，根据对象的引用关系搜索
- **引用计数法**：根据内存被引用的次数判断

