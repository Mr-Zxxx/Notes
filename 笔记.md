# 开发文档

### 第一层：最简可运行（MVP 必备）

| 文档           | 目的                       | 典型文件/位置                                   | 工具示例                |
| :------------- | :------------------------- | :---------------------------------------------- | :---------------------- |
| README.md      | 新人 5 分钟跑起来          | 根目录                                          | Markdown                |
| 环境清单       | 一键还原开发/测试/生产环境 | `docs/ENV.md` + Docker Compose / Nix / Brewfile | Docker, Nix             |
| 构建与部署脚本 | CI/CD 可重复               | `.github/workflows/`, `Makefile`, `deploy.sh`   | GitHub Actions, Jenkins |
| CHANGELOG.md   | 用户可见的变更记录         | 根目录                                          | Keep a Changelog 规范   |

> ✅ 小团队（<5 人）先保证这 4 个文件存在，就能做到“任何新人 30 分钟能跑起来”。

------

### 第二层：长期可维护（上线后必须补齐）

| 类别          | 文档                | 面向对象       | 关键内容                                 | 推荐工具                          |
| :------------ | :------------------ | :------------- | :--------------------------------------- | :-------------------------------- |
| **需求/产品** | PRD（产品需求文档） | 产品经理、客户 | 业务流程、角色权限、验收标准             | Notion、飞书多维表                |
| **技术设计**  | 系统架构图          | 全团队         | C4 Model（上下文、容器、组件、代码）     | draw.io、Structurizr              |
|               | ADR（架构决策记录） | 技术骨干       | “为什么用 Kafka 而不是 RabbitMQ”         | Markdown + `docs/adr/0001-xxx.md` |
|               | ER 图 / API 契约    | 前后端         | OpenAPI/Swagger、dbdiagram.io            | Swagger UI、dbdocs                |
| **代码级**    | 代码注释 & 类型     | 开发者         | JSDoc / TypeDoc / docstring              | IDE 自动生成                      |
|               | 模块 README         | 开发者         | 每个微服务/模块的入口、配置              | 同仓库                            |
| **测试**      | 测试策略            | QA、Dev        | 单元/接口/E2E 范围、测试数据             | `docs/TEST.md`                    |
|               | 回归测试用例        | QA             | 核心场景清单                             | TestLink、禅道                    |
| **运维**      | 运行手册（Runbook） | DevOps、值班   | 日志位置、重启命令、回滚步骤             | `docs/RUNBOOK.md`                 |
|               | 监控告警规则        | DevOps         | Prometheus rules、Grafana dashboard 链接 | YAML + README                     |
| **安全**      | 威胁建模报告        | 安全团队       | STRIDE、数据流图                         | Microsoft TMT                     |
|               | 依赖漏洞清单        | 全团队         | `pnpm audit`, `trivy` 报告               | GitHub Dependabot                 |

------

### 第三层：组织级治理（多项目/多团队协作）

| 文档                     | 目的          | 维护频率   | 工具                                |
| :----------------------- | :------------ | :--------- | :---------------------------------- |
| 产品路线图（Roadmap）    | 对齐商业目标  | 每季度     | Jira、ProductPlan                   |
| 技术债 Backlog           | 防止腐烂      | 每月       | Jira label: tech-debt               |
| 编码规范                 | 统一风格      | 每年       | ESLint/Prettier + `CONTRIBUTING.md` |
| 发布流程（Release Flow） | 灰度/回滚策略 | 每次大版本 | GitFlow 或 GitHub Flow 文档         |
| 灾难恢复计划（DRP）      | 机房/云故障   | 每半年     | `docs/DR.md` + 演练记录             |
| 数据字典 & 隐私合规      | GDPR/国密合规 | 随迭代     | OneTrust、自研表格                  |
| 交接文档（Handover）     | 人员流动      | 离职前     | Confluence 模板                     |

------

### 📁 目录模板（可直接用）

```
repo-root/
├── README.md
├── CHANGELOG.md
├── docs/
│   ├── ENV.md
│   ├── RUNBOOK.md
│   ├── TEST.md
│   ├── adr/
│   │   └── 0001-use-kafka-for-events.md
│   └── arch/
│       ├── c4-context.png
│       └── openapi.yaml
├── .github/workflows/ci.yml
└── CONTRIBUTING.md
```

------

### 落地建议

1. **先写“五分钟上手” README**，其他文档按故障/新人/交接痛点逐步补。
2. **文档即代码**：把 ADR、API 契约、监控规则全部进 Git，MR 评审强制更新。
3. **设立单一可信源**：需求用 Notion → 自动生成 Jira 任务 → 代码注释反向链接 PRD。
4. **每季度“文档可用性演练”**：随机抽新人 30 分钟从零搭建环境，失败就补文档。





# 数据库

#### 表的设计

表需要遵守表功能单一职责

需要考虑的数据的**流动方向性，保证逻辑上的操作统一**，例如**关注功能**

对于指定类型枚举类型查询效率更高，int扩展性更强

#### point数据类型

可以存储经纬度信息，并直接对空间数据处理



# Vue

### Vue 3 生命周期钩子

| 钩子                  | 用法说明                                                     | 注意事项 / 推荐场景                                       |
| --------------------- | ------------------------------------------------------------ | --------------------------------------------------------- |
| **setup()**           | 组件创建时执行，进行初始化，替代 `beforeCreate` 和 `created` | 这里不能访问 `this`，应使用组合式 API（ref、reactive 等） |
| **onBeforeMount()**   | 挂载前执行                                                   | 一般用得少，准备挂载相关数据                              |
| **onMounted()**       | 挂载完成，DOM 渲染完成                                       | 操作 DOM、调用第三方库的初始化                            |
| **onBeforeUpdate()**  | 数据变化触发视图更新前                                       | 不要在这里改响应式数据，避免死循环                        |
| **onUpdated()**       | 视图更新完成后                                               | 操作更新后的 DOM                                          |
| **onBeforeUnmount()** | 组件卸载前                                                   | 做资源释放、解绑事件等清理工作                            |
| **onUnmounted()**     | 组件卸载后                                                   | 已不能访问响应式数据                                      |
| **onActivated()**     | keep-alive 组件激活                                          | 恢复数据、重新发请求                                      |
| **onDeactivated()**   | keep-alive 组件停用                                          | 暂停定时器、保存状态                                      |

![组件生命周期图示](./assets/lifecycle_zh-CN.W0MNXI0C.png)



### 隐藏滚动条

| 浏览器        | 隐藏滚动条的方法                         |
| ------------- | ---------------------------------------- |
| Chrome/Safari | `::-webkit-scrollbar { display: none; }` |
| Firefox       | `scrollbar-width: none;`                 |
| IE/Edge       | `-ms-overflow-style: none;`              |

### 语法

v-html：解析内容中的标签为html元素





------

**⚠️ 注意：**

- 虽然滚动条不可见，但用户可以用 **鼠标滚轮 / 触摸板 / 手指滑动 / 键盘方向键** 来滚动。
- 不建议用于用户必须明确知道可滚动的区域，除非你能用箭头提示或动画引导用户。



# 网格布局

采用网格布局的区域，称为"容器"（container）。容器内部采用网格定位的子元素，称为"项目"（item）。

![img](./assets/1_bg2019032502.png)

# MapLibre GL JS

**MapLibre GL JS**（一个开源的 Web 地图库，与 Mapbox GL JS 兼容）



# ffmpeg

处理视频工具，可以用于截取视频封面



# 远程SSH开发

秘钥：

```
PS C:\Users\Admin> ssh-keygen -t rsa -b 4096
Generating public/private rsa key pair.
Enter file in which to save the key (C:\Users\Admin/.ssh/id_rsa): 
Enter passphrase (empty for no passphrase): 
Enter same passphrase again: 
Your identification has been saved in C:\Users\Admin/.ssh/id_rsa        
Your public key has been saved in C:\Users\Admin/.ssh/id_rsa.pub        
The key fingerprint is:
SHA256:gPoeX7hrO8Rrr1HgG+wUIFJZIMlT1gy6vOtuMlsm8Mo admin@DESKTOP-6A52IHN
The key's randomart image is:
+---[RSA 4096]----+
|+o=B*            |
|.=+. =           |
| .. . +          |
|. .. o +         |
|.o.  .= S        |
|.... oo=         |
|..+ o.=..        |
|+*.. o=+         |
|BE  .o**.        |
+----[SHA256]-----+
PS C:\Users\Admin> 

```



# 推送拉去数据去重最简方案

去重最简落地方案（≤ 1 MB 数据量通用）

小项目别一步到位抄 B 站那套“四层过滤”，**用最轻量的方案就能 99 % 解决**：

1. 后端接口一次性返回 **“最新 N 条” + 上次最后一条 id**
2. 前端用 **Set 去重** 就够了
3. 数据量不大，全量拉取，简单可靠

后端（伪代码）

```php
// 请求：GET /api/works?cursor=0&limit=20
$cursor = (int) request('cursor');
$list  = Work::orderBy('id','desc')
              ->where('id','<',$cursor)   // 只取比 cursor 小的
              ->limit(20)
              ->get();
return [
  'list' => $list,
  'next_cursor' => $list->last()->id ?? 0
];
```

前端（Vue/React 都一样）

```js
const ids = new Set();        // 会话级去重
const list = ref([]);

const loadMore = async () => {
  const { data } = await axios.get('/api/works', {
    params: { cursor: list.value.at(-1)?.id || 0, limit: 20 }
  });
  // 过滤重复
  const filtered = data.list.filter(item => !ids.has(item.id));
  filtered.forEach(item => ids.add(item.id));
  list.value.push(...filtered);
};
```

**小项目：后端给“时间戳游标+limit”接口，前端一个 Set 去重，20 行代码搞定，别上布隆过滤器。**



# JavaScript

### `??` （空值合并）

- 只在左边是 `null` 或 `undefined` 时才返回右边，其它情况直接返回左边。

```
console.log(0 ?? 100);     // 0   （不会被当成“空”）
console.log("" ?? "默认");  // ""  （保留空字符串）
console.log(null ?? "默认"); // "默认"
console.log(undefined ?? "默认"); // "默认"
```

### **可选链运算符（`?.`）**

可选链运算符 `?.` 用来 **安全地访问对象属性或调用方法**，避免因为 `null` 或 `undefined` 导致报错。

#### 用法

(1) **访问对象属性**

```
obj?.prop
```

- 如果 `obj` 存在，返回 `obj.prop`
- 如果 `obj` 是 `null` 或 `undefined`，返回 `undefined`

(2) **访问嵌套属性**

```
user?.address?.city
```

- 如果 `user` 或 `user.address` 是 `null`/`undefined`，直接返回 `undefined`

(3) **调用方法**

```
obj?.method?.()
```

- 如果 `obj.method` 存在，就执行
- 如果 `obj` 是 `null` 或方法不存在，不会报错，而是返回 `undefined`

(4) **访问数组元素**

```
arr?.[0]
```

- 如果 `arr` 存在，就取第一个元素
- 否则返回 `undefined`







# 搜索功能

通过搜索框拼接搜索页的path与keywords，跳转至搜索页

新页面加载前通过path获取keywords，拿到后向后端发起请求，

将查询结果进行渲染

在 Vue 中有两种思路：

------

##  使用传统跳转（浏览器刷新）

- **方式**：直接用浏览器的 URL 跳转。

- **做法**：

  - 点击搜索按钮时，获取输入框关键词。

  - 拼接成目标 URL，例如 `/search.html?keyword=xxx`。

  - 使用：

    ```
    window.location.href = '/search.html?keyword=xxx'
    ```

  - 浏览器会加载新的页面，搜索页可以通过 URL 获取关键词。

✅ **特点**：

- 页面会完全刷新。
- 不依赖 Vue Router。
- 适合多页应用（MPA）场景。

------

##  Vue Router 跳转（单页应用内）

- **方式**：`router.push()` 跳转到搜索页路由。

- **做法**：

  - 设置一个搜索页路由 `/search`。

  - 点击按钮：

    ```
    this.$router.push({ path: '/search', query: { keyword } })
    ```

  - Vue 会切换组件显示搜索页（不刷新整个页面）。

- **特点**：

  - URL 会更新（比如 `/search?keyword=xxx`）。
  - 页面不刷新，只是切换组件。
  - SPA 风格，更快、更流畅。

------

###  总结

- **如果你想要新页面刷新加载** → 用 `window.location.href` 或 `<a>` 标签。
- **如果你想保持 SPA 风格** → 用 `Vue Router` 跳转。

------

我可以帮你画一个**搜索框点击 → 新页面跳转 → 获取关键词 → 显示搜索结果**的完整流程图，让逻辑一目了然。

你希望我画吗？

### **搜索功能流程（传统多页跳转版）**

1. **输入内容**

   - 用户在搜索框里输入关键词。
   - 输入内容存到一个变量，比如 `keyword`。

2. **点击搜索按钮**

   - 点击事件触发方法。

   - 方法里把输入的关键词拼接到 URL，比如：

     ```
     /search.html?keyword=xxx
     ```

3. **跳转到新页面**

   - 用 `window.location.href = 拼接好的URL`。
   - 浏览器加载 `/search.html` 页面。

4. **新页面解析关键词**

   - 新页面一加载时，从 URL 里获取 `keyword` 参数。
   - 可以用 `URLSearchParams` 或其它方式解析。

5. **执行搜索并渲染结果**

   - 拿到关键词后，调用后端接口或者本地数据进行搜索。
   - 渲染搜索结果列表给用户看。

### 路径解析

**原生 JavaScript（浏览器环境）**

可以使用 `URLSearchParams` 轻松解析：

```js
// 假设当前页面是你的 URL 示例
const urlParams = new URLSearchParams(window.location.search);
const rawKey = urlParams.get("key"); // 获取 URL 编码后的值
const keyword = decodeURIComponent(rawKey); // 解码成可读字符串
console.log(keyword); // 输出："想看看什么呢~"
```







# 会话

##  **会话（Session）一般指什么？**

**会话（Session）**指的是 **一次用户和服务器交互的状态**，从用户登录或访问开始，到退出或超时结束的这段时间。

###  作用

- 记录用户状态（是否登录）
- 保存用户在一次访问过程中的临时数据
- 方便在多次请求之间保持用户身份信息

###  典型使用

1. **用户登录**
   - 用户输入账号密码 → 验证成功
   - 服务器生成 Session（如随机 session_id） → 返回给用户（通常存 cookie）
   - 用户后续请求带上 session_id，服务器识别用户身份
2. **购物车**
   - 未登录用户也可以往购物车加东西
   - 这些临时数据存 Session，关闭浏览器或超时后消失
3. **权限控制**
   - Session 中可以存用户角色或权限
   - 访问受限页面时检查 Session 信息

###  存储方式

- **服务器端存储**（最常用）
  - PHP：`$_SESSION`
  - Node.js/Express：`express-session`
- **客户端存储 session_id**
  - Cookie、LocalStorage、JWT（Token）

## 用户管理

用户管理是对用户账号及权限的整体管理，重点是**用户信息和行为管理**，而 Session 只是其中的一个工具。

###  包含内容

1. **用户注册、登录、注销**
2. **密码和身份验证**
3. **权限控制（角色/资源访问）**
4. **用户信息维护**（头像、昵称、联系方式）
5. **会话管理**（登录状态、Token、Session 生命周期）

------

###  总结对比

| 名称            | 定义                             | 作用                               |
| --------------- | -------------------------------- | ---------------------------------- |
| 会话（Session） | 一次用户访问服务器的交互状态     | 保存登录状态、临时数据、权限信息   |
| 用户管理        | 系统对用户账号、权限和行为的管理 | 维护用户身份、信息、权限、登录控制 |

------

简单理解：

- **用户管理**：管理“谁是用户，能做什么”
- **会话（Session）**：管理“用户现在在干什么，当前状态是什么”



# 状态管理

##  只在当前页面有效（短期状态）

- **适用场景**：页面刷新会丢掉状态，只需要当前组件或页面使用

- **实现方式**：

  1. **组件内部 state**（Vue 里的 `data` 或 React 的 `useState`）

     ```
     const status = ref(null); // Vue 3
     axios.get('/api/status').then(res => status.value = res.data);
     ```

  2. **页面级 reactive / ref**（Vue 3）

     - 用 `reactive` 或 `ref` 保存请求结果

✅ 优点：简单，不需要额外依赖
 ❌ 缺点：刷新页面就丢失

------

##  跨组件共享（短期）

- **适用场景**：多个组件都需要访问请求结果，但不需要永久保存

- **实现方式**：

  1. **Vuex / Pinia（Vue）**

     ```
     // store.js
     const useStore = defineStore('main', {
       state: () => ({ status: null }),
       actions: {
         fetchStatus() {
           axios.get('/api/status').then(res => this.status = res.data)
         }
       }
     })
     ```

  2. **React Context / Zustand / Redux（React）**

✅ 优点：方便跨组件共享
 ❌ 缺点：刷新页面会丢失

------

##  跨页面或刷新后仍保持状态（长期状态）

- **适用场景**：用户刷新页面后仍要保留状态，例如登录状态、偏好设置

- **实现方式**：

  1. **LocalStorage / SessionStorage**

     ```
     // 保存
     localStorage.setItem('status', JSON.stringify(res.data));
     // 读取
     const status = JSON.parse(localStorage.getItem('status'));
     ```

     - `LocalStorage`：永久保存
     - `SessionStorage`：浏览器关闭后清空

  2. **IndexedDB**

     - 更复杂的数据结构或大容量数据
     - 用于离线缓存

✅ 优点：刷新不丢失，简单
 ❌ 缺点：前端数据可能被篡改，安全敏感数据不建议存

------

##  状态管理 + 本地存储结合（推荐）

- 对于复杂应用，建议：
  - **全局状态管理（Vuex/Pinia）** 保存状态
  - **LocalStorage** 做持久化
  - 页面加载时先从 LocalStorage 初始化状态，再发请求同步

```
// Vue 3 + Pinia 示例
const useStore = defineStore('main', {
  state: () => ({
    status: JSON.parse(localStorage.getItem('status')) || null
  }),
  actions: {
    fetchStatus() {
      axios.get('/api/status').then(res => {
        this.status = res.data;
        localStorage.setItem('status', JSON.stringify(res.data));
      })
    }
  }
})
```

✅ 优点：刷新页面不丢失状态，跨组件共享方便

------

###  总结选择策略

| 生命周期           | 方式                                     |
| ------------------ | ---------------------------------------- |
| 页面级（短期）     | 组件内部 state / ref / reactive          |
| 跨组件（短期）     | Vuex / Pinia / Context / Redux           |
| 刷新不丢失（长期） | LocalStorage / SessionStorage + 状态管理 |



# Vuex

### 创建

```js
import { createStore } from 'vuex'

const store = createStore({
  state: {
    user: JSON.parse(localStorage.getItem('user')) || null,
    token: localStorage.getItem('token') || ''
  },
  mutations: {
    setUser(state, user) {
      state.user = user
      localStorage.setItem('user', JSON.stringify(user)) // 同步到 localStorage
    },
    setToken(state, token) {
      state.token = token
      localStorage.setItem('token', token)
    },
    logout(state) {
      state.user = null
      state.token = ''
      localStorage.removeItem('user')
      localStorage.removeItem('token')
    }
  },
  actions: {
    login({ commit }, { user, token }) {
      commit('setUser', user)
      commit('setToken', token)
    },
    logout({ commit }) {
      commit('logout')
    }
  }
})

export default store
```

### 组件中使用

```js
import { useStore } from 'vuex'
import { computed } from 'vue'

export default {
  setup() {
    const store = useStore()

    const user = computed(() => store.state.user)

    const login = () => {
      const userData = {id: 1, name: 'Alice'}
      const token = 'abc123'
      store.dispatch('login', { user: userData, token })
    }

    const logout = () => {
      store.dispatch('logout')
    }

    return { user, login, logout }
  }
}

```



# 防火墙规则

查看防火墙规则

### firewalld（CentOS 7+/RHEL）

```
sudo firewall-cmd --list-all
```

会列出当前区域（zone）的端口和来源 IP。
 如果用了 `--add-rich-rule`，可以这样查：

```
sudo firewall-cmd --list-rich-rules
```

------

### ufw（Ubuntu/Debian）

```
sudo ufw status verbose
```

会显示类似：

```
22/tcp                   ALLOW IN    1.2.3.4
```

表示 22 端口只允许 1.2.3.4 访问。

## 设置规则

### CentOS 7+/RHEL (firewalld)

 只允许 `1.2.3.4` 访问 **22 端口**：

```
sudo firewall-cmd --permanent --add-rich-rule="rule family='ipv4' \
source address='1.2.3.4' port protocol='tcp' port='22' accept"
sudo firewall-cmd --reload
```

 如果只允许一个网段（比如公司网段 `1.2.3.0/24`）：

```
sudo firewall-cmd --permanent --add-rich-rule="rule family='ipv4' \
source address='1.2.3.0/24' port protocol='tcp' port='22' accept"
sudo firewall-cmd --reload
```

 查看规则：

```
sudo firewall-cmd --list-rich-rules
```

------

###  Ubuntu/Debian (ufw)

 默认拒绝：

```
sudo ufw default deny incoming
```

 只允许某个 IP 访问 SSH：

```
sudo ufw allow from 223.74.156.51 to any port 22 proto tcp
```

 如果要开放一个网段：

```
sudo ufw allow from 1.2.3.0/24 to any port 22 proto tcp
```

 查看规则：

```
sudo ufw status verbose
```



```html
    <!-- element-ui -->
    <!-- Import style -->
    <link rel="stylesheet" href="//unpkg.com/element-plus/dist/index.css" />
    <!-- Import Vue 3 -->
    <script src="//unpkg.com/vue@3"></script>
    <!-- Import component library -->
    <script src="//unpkg.com/element-plus"></script>
    <!-- 地图LocationIQ API  -->
    <script src='https://tiles.locationiq.com/v3/libs/maplibre-gl/1.15.2/maplibre-gl.js'></script>
    <link href='https://tiles.locationiq.com/v3/libs/maplibre-gl/1.15.2/maplibre-gl.css' rel='stylesheet' />
    <script src='https://tiles.locationiq.com/v3/js/liq-styles-ctrl-libre-gl.js?v=0.1.8'></script>
    <link href='https://tiles.locationiq.com/v3/css/liq-styles-ctrl-libre-gl.css?v=0.1.8' rel="stylesheet" />
    <script src="https://tiles.locationiq.com/v3/js/lang-libre-gl.min.js?v=0.1.8"></script>
    <link href="{:config('WEB_SITE_ICO')}" type="image/x-icon" rel="shortcut icon" />
    <!-- axios -->
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>


    <!-- Vue -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
```



# END

