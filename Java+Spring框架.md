[TOC]

# 目录

[TOC]

# Java

## **Java基础**

### 1、什么是 Java 中的不可变类？

被final关键字修饰的类是不可变类，不可变类无法被继承，成员变量也无法被修改



### 2、Java 中的序列化和反序列化是什么？

序列化即将Java对象转化为字节流文件便于实现持久化。反序列化即将字节流文件转化为Java对象，通常通过Serializable接口实现



### 3、你认为 Java 的优势是什么？

1. **面向对象的编程语言**
2. **JVM跨平台运行**
3. **丰富的第三方库、生态**
4. 垃圾回收机制



### *4、Java 中的参数传递是按值还是按引用？

按值传递。无论是基本数据类型还是饮引用数据类型，都是按值传递。

引用类型 作为参数时，传递的是引用地址的副本，也就是传递的地址的拷贝值



### 5、Java 方法重载和方法重写之间的区别是什么？

重载是指相同的方法名不同的参数的不同调用

重新是指在父类的继承/接口的实现时，对类的扩展时，对继承/实现的方法进行重写



### *6、什么是 Java 内部类？它有什么作用？

内部类指的是**定义在类的内部的类**。内部类分为<u>成员、局部、静态、匿名</u>内部类。

使用内部类将具有相同业务逻辑的代码定义在一个类的内部可以**提高代码的内聚性，简化代码结构，减少代码的冗余**



### ***7、JDK8 有哪些新特性(7个)？**

- 用**元空间**代替了永久代：HotSpot虚拟机中永久代回收效率太低
- 引入了**Lamda表达式**：一种匿名函数，可以像参数一样传递，使代码更简洁更灵活
- 引入了**新的日期类**：新的日期类不可变且线程安全增加了
- **Optional类**：解决NullPointerException问题
- 提供**接口默认方法 、静态方法**：将相关方法内聚，不必创建新的对象
- 新增**Stream流式接口**：便于数据处理，链式操作并行处理 
- **CompletableFuture类**：提供了新的异步编程模型



### 8、Java 中 String、StringBuffer 和 StringBuilder 的区别是什么？

String被final关键字修饰不可被继承不可被修改

**StringBuffer**可以被修改，可变的可以对字符串进行增删改操作，**线程安全**。**适合多线程**

**StringBuilder**也可以被修改，**线程不安全，因此性能比StringBuffer好。适合单线程**



### 9、Java 的 StringBuilder 是怎么实现的？

- StringBuilder底层使用**字符数组实现**
- 内部提供了append、insert、replace等方法用于修改字符数组，而不再重新new一个String对象
  在对StringBuilder进行操作时，首先会判断操作的字符所占用的空间，再判断数组是否能容纳操作的字符或者是否能缩容。最后在将操作的字符扩容加入/删去缩容
- 但字符数组的空间不足时，字符数组以原来的**2倍扩容**。





### 10、JDK 和 JRE 有什么区别？

JDK是指**Java开发套件，包含了JRE、以及编译器、打包工具、调试工具**等用于开发调试Java应用

JRE是指**Java运行环境，包含了JVM、核心类库、配置文件、库文件**等



### 11、你使用过哪些 JDK 提供的工具？

JDK提供的主要工具：

- **javac：java编译器。将.java文件编译成字节码文件.class格式**
- **java：java应用程序启动器，用于运行Java程序**
- **javadoc：生成HTML格式的api文档**
- jdb：Java调试工具
- **jar：用于创建和管理jar包文件**

性能监控分析：

- jmap：内存映射工具，内存泄漏分析和垃圾回收优化
- jhat：堆分析工具，帮助开发者了解内存使用情况



### **12、Java 中 hashCode 和 equals 方法是什么？它们与 == 操作符有什么区别？**

- hashCode是在散列结构中，用于比较两个元素是否相等。本质上是比较两个元素的哈希值是否相等，通过比较hash值，快速确认两个值是否相等
- **equals方法：比内容**。是比较两个值/对象中的属性是否相等。如果比较的是对象，通常需要重写equals方法
- **==：比地址**。比较的是两个引用是否指向同一块地址空间。如果是基础数据类型，比较的是他们的值



### **13、Java 中的 hashCode 和 equals 方法之间有什么关系？**

equals的默认实现是==比较运算法，hashcode是返回对象的哈希值，可以通过比较hash值判断两个对象是否相等，相同的对象返回的hash值必须是相等的。

- **如果两个对象的equals运算的结果是相等的，那么他们hashcode比较的结果必定是相等的。**
- **hashcode比较结果相等，equals方法比较的结果却不一定相等**



### *14、什么是 Java 的 SPI（Service Provider Interface）机制？

一种**为服务框架提供服务实现的机制**。它**允许框架在运行时动态的发现服务的实现**，以便模块化设计

核心思想是通过配置文件声明服务提供者的实现，Java运行时**通过配置文件找到并加载相应的服务实现**



### 15、Java泛型的作用是什么？

泛型的指定通过<u>**在编译时检查类型安全**，**避免**在运行时出现**类型转换错误**。</u>

- 类型安全：类型安全检查**确保**在代码执行时**不会出现类型不匹配**的问题。
- 代码重用：泛型可以使不同的数据类型使用同一段相同逻辑的代码
- 避免了显示类型转换：在编译时指定了类型，不必在运行时进行显示类型转换，减少了性能开销



### 16、Java 泛型擦除是什么？

<u>编译时清除泛型信息，保证兼容性。Java1.4之前没有引入泛型</u>

Java代码在**编译时对所有泛型信息进行删除**的过程。确保与java1.4版本以及之前的版本**保持向下兼容**。Java1.4之前没有引入泛型。在泛型擦除后编译器会选择合适的类型替换泛型类型参数。使用对象的上限替代掉类型参数。**默认采用Object**类型作为替代。或者**在插入类型元素时对元素类型进行检查转换**



### 17、什么是 Java 泛型的上下界限定符？

上下界限定符主要是用于**对泛型的类型参数进行范围限制**。

- **上界限定符<？extends T>**：表示泛型参数必须是**T/T的子类**。**通常用于读取操作**。例如上界限定符Number类型，可使用Integer、Double参数类型
- **下界限定符<？super T>**：表示泛型参数必须是**T/T的父类**。**通常用于写入操作**。确保能够正确将对象插入至集合中



### ***18、Java 中的浅拷贝和深拷贝有什么区别？**

- 浅拷贝：**创建一个对象但对对象内的引用类型只会复制对象地址**，相当于创建对象后只复制了对象地址引用，并没有真正的将地址内的内容拷贝过来，**对浅拷贝对象的修改会影响到原来的被拷贝对象**。Java中clone()默认实现浅拷贝操作
- 深拷贝：则不仅复制了拷贝的对象，还将**对象中的所有引用都我试试现在递归的复制了一份到新的地址空间**，**对深拷贝对象的修改不会影响到原来的被拷贝对象**。实现深拷贝有两种方式：一种是通过**递归调用clone()方法**，另一种是通过序列化和反序列化

- 引用拷贝：复制的只是目标的引用地址。引用变量的=赋值就是引用拷贝



### **18-1、怎么实现深拷贝？**

深拷贝有两种方式：

1. 一种是通过**递归调用clone()方法**，
2. 另一种是通过序列化和反序列化



### 19、什么是 Java 的 Integer 缓存池？

**<u>对Integer型（-128-127）数据缓存，使用时不用再创建对象装箱，速度更快</u>**

Java包装类型有自动拆箱/装箱机制。当我们每次**使用Integer类型时都需要装箱拆箱会造成较多的性能浪费**。所以java**为了提升性能提供了Integer缓存池**，缓冲池会将常用的int值(-128~127)缓存在缓存池中，当我们需要这些值时，就不必临时创建Integer对象，**提高性能。还能节约内存**，因为**减少了对象的频繁创建可以降低垃圾回收机制的负担**



### 20、什么是 Java 的 BigDecimal？

Java中**用于高精度计算的类**，BigDecimal类具备**高精度**、**不可变性**、**丰富的计算功能**等特点，**提供了对浮点数和定点数的精确控制**。常用于金融和科学计算等需要高精度计算的领域



### 21、为什么在 Java 中编写代码时会遇到乱码问题？

因为在**编码时字符集与解码时使用的字符集不一致**导致的。常见的有以下情况：

- 默认编码设置问题：Java默认采用的操作系统的字符集，不同操作系统采用字符集不一致
- 流处理中编码设置问题：流处理时没有指定字符集采用了默认编码。
- 数据库乱码：数据库字符集与应用的字符集不一致



### 22、为什么 JDK 9 中将 String 的 char 数组改为 byte 数组？

<u>原本是UTF-16占两个字节，改成了**coder变量标识编码**改byte占一个字节，节约内存</u>

JDK9之前虽然是**基于char[]数组实现的，但内部采用的是UTF-16编码**，每个字符需要占用两个字节。**如果当前字符只需要一个字节的空间就造成了性能浪费**。例如Latin-1z字符。

**JDK9之后，字符串引入了coder变量标识编码方式**，当字符串只包含存在处于Latin-1范围之内字符时，使用单字节编码，**节省内存**。否则使用UTF-16编码。



### 23、栈和队列在 Java 中的区别是什么？

- **栈只允许在一端进行数据操作**，即入栈和出栈。遵循**先进后出**原则。Java中Stack类实现了这个数据结构。通常用于**函数调用，表达式求值，回溯算法（DFS）**
- **队列允许一端插入，另一端取出**。即入队和出队。遵循**先进先出**原则。Java中Queue类实现了这个数据结构。**通常用于任务调度、资源管理、数据流处理（BFS）**



### 24、Java 的 Optional 类是什么？它有什么用？

<u>**Java8引入的容器类，表示可能为空的值**。**减少出现null的情况**。避免**NullPointerException**的发生。</u>

Optional类可以包含一个值，也可以为空。分别表示值存在和值不存在。**使用Optional代替null避免了使用Null表示值不存在**



### 25、Java 的 I/O 流是什么？

<u>**指输入输出流，分别有输入流、输出流、字节流、字符流。**</u>

I/O流是指Java处理数据的输入/输出的相关功能。包括了一些处理数据的类库和基本操作。可以读取网络/硬盘中的数据，也可以向目标位置写入数据。

其中主要分为**字节流**和**字符流**。

**字节流：**相应的类通常以**InputStream和OutputStream**为后缀。处理8位的字节数据，常见的有图片、视频、文件等。**例如FileInputStream、BufferedInputStream、DataInputStream等**

**字符流**：则用常以**Reader和Writer**为后缀。处理16位的字符数据，通常用于处理文本信息和文本文件。**例如FileReader、BufferedReader、DataReader等**

还有对基础流的增强包装**缓冲流，缓冲流的内置缓冲区大大提高了I/O的性能。**

 

### 26、Java 中的访问修饰符有哪些？

public 公开、protected 保护、default 默认、private 私有

同包、同类、子类、其他



### 27、Java 中静态方法和实例方法的区别是什么？

<u>**静态方法属于类，实例方法属于对象实例**</u>

静态方法是属于类的而不是属于类的实例的。

静态方法可以直接通过类名调用。

随着类的加载而加载，类的卸载而消失



### 28、什么是 Java 中的双亲委派模型？

<u>Java的**类加载机制。类加载器在加载时会将类的加载委派给该类的父类加载器**</u>

类加载器在加载某个类时，会将**类的加载委派给该类的父类加载器**。父类再将加载委托给父类加载器直至根加载器。父类加载器无法加载时，才由当前类自行加载。



### 29、Java 和 Go 的区别

**设计理念**：

- Java注重面向对象编程**，具有封装继承多态等特性**。同时Java程序是运行在JVM之上的，实现了**一次编写，到处运行的**跨平台特性。Java设计目标是**提供一个灵活可扩展的通用编程平台。**
- Go注重**面向系统级编程和并发处理**。强调**简单的语法和快速的编译**，注重简洁和高效的编程语言。设计目标是**提高开发者的生产力。**

**并发模型**：

- Java的并发模型依靠的是**Thread类和Executor框架管理**并发任务。并发编程需要**显式的创建、同步、资源共享**
- Go是**基于Goroutine的**，比操作系统线程**更轻量级的线程**。**简化**了**线程通信和同步**

**内存管理**：

- Java的垃圾回收机制拥有多种GC算法，可根据不同场景选择不同的方案。
- Go同样具有垃圾回收机制，但**设计上更简洁，专注减少GC开销，**适合处理大量并发请求。

**应用场景**：

- Java常用于**企业系统开发**、Web开发、以及安卓开发等业务开发。具有丰富的三方库提供完整的企业开发生态。
- Go一**般用于云计算等高性能服务端开发**。Go的简洁设计为高性能并发处理提供了更好的表现力



### 30、Java Object 类中有什么方法，有什么作用？

- **equals()**：比较两个对象是否相等
- **hashCode方法**：返回对象的哈希码。
- toString方法：返回对象的字符串表示
- **getClass方法**：返回运行时的Class类对象，final修饰，不能被重写
- **notify/notifyAll方法**：唤醒等待的 (所有) 线程，需要在同步块/同步方法中调用。
- **wait方法：**使当前线程等待
- **clone方法**：创建对象并返回当前对象的副本。默认实现浅拷贝（基本数据类型深拷贝，引用数据类型只拷贝地址）



## **集合框架**

### 1、Java 中 for 循环与 foreach 循环的区别是什么？

- for语句是传统的循环语句，可以控制循环的初始化、循环条件、步进迭代
- f**oreach是Java5引入的简化循环结构**，用于遍历数组或者实现了Iterable接口的集合。优点如下：
  - 语法更简洁。提高可读可维护性
  - 只读访问。
  - 不可修改集合结构。保证集合内部安全

### 2、什么是 Java 中的迭代器（Iterator）？

**用于遍历集合中元素的对象**，Java提供了一种统一的方法来访问集合中的元素，而**不需要关注实现具体代码**，就像一个指针一样，可以依次指向集合中的每个元素



### **3、如何优化Java中的字符串拼接操作？**

- 使用StringBuffer / StringBuilder类
- 使用+运算符，底层使用StringBuilder实现
- 使用String.join方法，底层使用StringBuilder



### 4、介绍 Java 集合框架中常用的接口和类

接口：

- Collections：
- List：
- Set：
- Map：

类：

- List：Vector（线程安全）、ArrayList（数组）、LinkedList（链表）
- Set：HashSet（HashMap）、TreeSet（有序）、LinkedHashSet（哈希+链表）
- Map：HashMap（哈希+数组）、TreeMap、HashTable（线程同步）、ConcurrentHashMap（线程同步）



### <u>5、HashMap 和 ConcurrentHashMap 在多线程环境下的使用差异</u>

- HashMap线程不安全，使用数组+链表/红黑树实现，当链表中元素>8时，转换为红黑树
- ConcurrentHashMap线程安全，Java1.7以前用Segment分段锁实现，而不用对整个哈希表加锁，粒度更细。java1.8以后用Synchronized同步锁+CAS实现



### 6、比较 ArrayList 和 LinkedList 的区别

- ArrayList底层使用数组实现，随机访问，读写操作快
- LinkedList底层使用链表实现，顺序访问，增删操作快



### **7、List中的sort方法是怎么实现的？+**

**TimSort**，**插入排序+归并排序。**

将列表中数组分为多个子数组，子数组**内部使用插排**，对于**整个数组使用归并排序**









## **面向对象**

### 1、Java 中的基本数据类型有哪些？

有byte、short、int、long、float、double、char、boolean

占用内存分别是：1、2、4、8、4、8、1、1



### 2、Java 中包装类型和基本类型的区别是什么？



Java提供了8种基本数据类型，分别是byte、int、short、long、float、double、char、boolean。每一种基本数据类型都提供了其包装类。主要原因是因为**<u>Java作为面向对象编程语言，经常需要使用Object引用而不是基本数据类型。Java提供了自动拆箱装箱机制，便于包装类型的使用</u>**。区别在于

- **性能不同**：包装类型需要拆箱装箱需要性能消耗
- **默认值不同**：包装类型的默认值为null，基本数据类型可以是0/false
- **创建方式不同**：基本数据类型可以用=赋值，包装类型需要使用new关键字
- **存储方式不同**：基本数据类型存储在栈中，包装类型存储在堆中
- **比较方式不同**：基本数据类型比较运算符比较值的大小，而包装类型比较的是对象的地址是否相同



### 3、什么是 Java 中的自动装箱和拆箱？

自动装箱：是Java编译器自动将基础数据类型转换成包装数据类型。

自动拆箱：是Java编译器自动将包装数据类型转换成包装数据类型。

底层是通过调用**包装类型的valueof方法和xxxValue方法**实现的



### 4、什么是 Java 中的继承机制？

面向对象的核心机制之一。类可以通过extend关键字继承被继承类中的一些成员方法和成员变量。

子类通过继承可以提高代码的复用、使代码更易维护。缺点就是使得代码紧耦合，父类的修改会影响到子类



### 5、什么是 Java 的封装特性？

面向对象的核心机制之一。类将成员变量和成员方法封装在类的内部，**仅通过提供公共的接口供外部访问**。主要**目的是隐藏类的内部具体实现**，**只暴露必要的功能。从而保护类的完整性和减少系统的复杂性。**



### *6、什么是 Java 的多态特性？

**同一个父类引用/接口**指向不同的实例对象，**不同的子类实**例在运行时**调用相同父类或接口方法展现出不同的行为**叫多态。



### 7、使用 new String("str") 语句在 Java 中会创建多少个对象？

**一个或者两个**。需要根据常量池中是否存在的引用的不同情况而定。在JVM中存在着一个**字符串池，其中保存着很多String对象，并且可以被共享使用**，因此它提高了效率

主要分为两种情况：

- **常量池中没有引用**：Java会**在堆创建两个对象**，其中一个字符串对象创建在常量池中，另一个复制常量池中的对象交给String引用
- **常量池中有引用**：则**只会在堆中创建一个字符串对象引用**

将`String s = new String("abc")`拆开看其中`String s =`只是声明了一个引用变量。`new String("abc")`。才真正的创建了一个String对象。而String的构造方法其中的参数也是"abc"。本质上还是将常量池中“abc”对象传入构造方法内。

另外String a="ab"+"cd"，则是创建了三个对象。因为String是被final修饰的，无法修改，只能通过重新创建对象合并字符串。



### *8、为什么 Java 不支持多重继承？

因为多重继承**会出现菱形继承问题**，导致子子类继承来自同一个父类的子类对象时相同的方法**会产生歧义**，程序无法区分调用的哪一个方法。

至于为什么可以接口多实现，在Java8之前接口的实现必须重写接口方法，Java8之后有了默认方法也要求必须重写



### 9、接口和抽象类有什么区别？

首先是设计理念上的不同：

- 接口类的设计思想是**自上而下**的。在设计初期先根据某一行为定义通用的方法，在接口的实现时重写定义的方法
- 抽象类的是**自下而上**的。先有了子类的实现，再对子类中相同的方法和共性进行抽象

继承方式：

- 接口类可以多实现，但必须重写默认方法
- 抽象类不可多继承，避免出现菱形继承的问题

内部的方法类型不同：

- **接口类中的所有方法都是public、static、final修饰的**
- 抽象类中可以包含构造函数，成员变量可以有不同的访问修饰符



### 10、Java 的类加载过程是怎样的？

主要分为三个过程：加载、连接（验证—准备—解析）、初始化

- **加载**：将**二进制文件读取到内存中**，**生成Class对象**
- **连接**：
  - **验证**：验证二进制文件**是否符合一定格式，规范以及是否符合当前JVM版本**
  - **准备**：为静态变量**分配内存空间**
  - **解析**：将常量池中的**符号引用转化为直接引用**
- **初始化**：**执行静态代码块，为静态变量赋值**





## **异常**



### *1、Java 中 Exception 和 Error 有什么区别？

Exception是指异常，异常分为**运行时异常**和**编译时异常**，异常可以被程序捕获的并处理恢复。常见的有IO异常、SQL异常、NullPoint异常、IndexOutOfBounds异常

Error指错误，一般指系统级的发生错误而终止。无法被捕获处理，发生错误程序会被终止。通常有内存耗尽、栈溢出

![image-20250609224738083](./assets/image-20250609224738083.png)

### 2、Java 中 final、finally 和 finalize 各有什么区别？

- final关键字通常用于修饰常量。可以用于类、方法、变量上。

  - 被final修饰的类不可被继承
  - 被final修饰的方法不可被重写
  - 被final修饰的变量不可被修改

  通常用于设计不可变的类。确保类的安全性

- finally通常与try-catch语句一同使用。在执行try-catch语句块后，如果使用了finally代码块，确保异常发生后代码块一定会执行。通常在finally语句块中编写释放资源的相关代码。



### 3、Java 运行时异常和编译时异常（受检异常）之间的区别是什么？

区别主要在：**发生时机、捕获/处理方式、设计思想**

**发生时机：**

- **编译时异常发生在源文件编译阶段**，编译器会检查这些异常，如果不处理。程序则无法通过编译。
- **运行时异常发生在程序运行阶段**，程序员可以选择是否处理他们。通常是**程序逻辑错误导致的**

**捕获/处理方式：**

- 编译时异常：**需要在代码中显式处理**。要使用try-catch/throws关键字声明异常
- 运行时异常：**可以不用显式处理**，使用Try-catch捕获处理**或让程序终止时JVM抛出。**

**设计思想：**

- **编译异常一般是由外部因素导致的**，例如文件IO、数据库连接。**开发者无法预测，需要编译器强制要求处理**
- 运行异常是由**代码逻辑错误/漏洞引发的**，是程序**内部问题。可以在调试阶段发现**

**类型：**

- **编译（受检）**：IOException、SQLException
- **运行时：**NullPointerException、ArrayIndexOutOfBoundsException



### 4、Java异常怎么处理？

1. **未捕获 - JVM默认处理：**如果没有被任何调用者捕获，最终异常会由 JVM 处理，程序会**终止并打印堆栈异常信息。**
2. **try-catch 语句**：
   - **try**：将可能抛出异常的代码放在 `try` 块中。
   - **catch**：捕获并处理抛出的异常。一个 `try` 块可以有多个 `catch` 块，用于捕获不同类型的异常。
3. **throws 关键字**：
   - 在方法签名中使用 `throws` 声明方法可能抛出的异常，调用该方法的代码需要处理这些异常。
4. **throw 关键字**：
   - 手动抛出一个异常对象，返回给方法的调用者，通常用于自定义异常或特定逻辑。
5. **声明异常处理器：**在Spring框架中，可以通过`@ControllerAdvice`和`@ExceptionHandler`注解来实现全局异常处理。



### 5、异常中常见的方法



## **并发和多线程**

### 1、Java 中 wait() 和 sleep() 的区别？

都是**用于暂停线程的操作**。

首先，使用的要求不同：

- **wait方法必须在同步块/同步方法内调用**。**否则会抛出异常**。wait依**赖对象锁**来管理线程的等待和唤醒机制。**调用后**线程**释放对象锁**，进入等待状态。
- **sleep方法可以在任何上下文调用**，不需要获取对象锁。调用后线程休眠不会释放任何锁

所属类不同：

- **wait方法**所属**Object类**
- **sleep方法**所属类**Thread类**

恢复方式不同

- **wait方法**暂停的线程需要用**notify方法/notifyall方法唤醒**，或者**使用超时函数唤醒**
- **sleep方法**会在**指定的时间后自动恢复**运行。或者通过**抛出InterruptedException恢复**

用途不同

- **wait**方法常用于**线程通信**，通过notify方法**协调线程工作**
- **sleep**方法用于使线程暂停一会。**模拟延时/控制执行频率**



### 2、如果一个线程在 Java 中被两次调用 start() 方法，会发生什么？

抛出**非法线程状态异常**。

会出现**illegalThreadStateException**异常。因为**一个线程只能被启动一次。一旦被启动，则无法回到初始状态**。



### 3、Java中创建线程的方法有哪些？

- 继承Thread类（本质上是实现Runnable接口）
- 实现Runnable接口
- 实现Callable接口，FutureTask处理结果（有返回值时用）



### 4、线程池有哪些核心参数？

- 核心线程池数
- 最大线程池数（>=核心线程池数）
- 多余线程存活时间
- 时间单位
- 等待队列
- 创建线程工厂
- 拒绝策略



### **5、什么是线程安全？怎么保证线程安全？**

在多线程的情况下，保证代码和数据的正确和一致，不会因为多个线程对数据的处理而导致数据的不一致。

<u>使用锁机制、原子操作、线程安全的集合类</u>



### 6、Java中有哪些集合的类是线程安全的？ArrayList是线程安全吗？

Vector数组、Hashtable、CurrentHashMap

ArrayList不安全



### 7、进程和线程的区别？为什么说线程切换的开销比进程的切换开销小？

**进程**是**资源分配**的基本单位，**线程**是**系统执行**的基本单位，进程由多个线程组成。进程内的线程互相共享资源

- 线程上下文比较小，切换时性能开销小

- 线程在进程内的资源是共享的
- 线程属于同一个进程，权限分配的开销也小





### 8、并发编程解释volatile关键字的作用+

volatile用于修饰变量，它有**内存可见性、禁止指令重排序**的特点

- **内存可见性：**线程修改该变量的值会在**主内存**中始终保持一致，并且其他线程立即可见
- **禁止指令重排序：**JVM虚拟机优化会改变指令顺序，对该变量操作的指令不会重新排序。

常用于**状态标志量、双重校验锁**



### <u>9、start()和run()方法有什么区别？</u>

- run方法中用于写需要执行的代码，是接口Runnable中的方法，直接调用run方法不会开启多线程。相当于一个任务
- start方法用于启动一个新的线程，属于Thread类，使用该方法后，JVM会为该线程分配所需要的资源，之后再调用run方法



### 10、线程的生命周期？

新建 > 就绪 > 运行 > 就绪/阻塞/死亡 > 阻塞(sleep/wait)/死亡 > 死亡





## **反射**

### 1、什么是 Java 中的动态代理？

**动态代理**是Java的一种**允许在程序运行时创建代理对象的机制**。程序不需要在编译时就确认具体的对象，在运行是决定代理对象的行为。这样使得程序可以在不修改目标对象的情况下对它进行增强/调整修改

动态代理**是Java反射机制的一种应用**

优点：

- 简化代码，减少重复的代码、
- 增强代码的灵活性，在运行时可以动态改变代理对象的行为
- 实现AOP，面向切面编程的基础是动态代理



### 2、JDK 动态代理和 CGLIB 动态代理有什么区别？

- **JDK动态代理是基于接口的**，**要求动态代理的对象一定是有定义接口的**

- **CGLIB是基于字节码生成工具**，**通过继承的方式生成目标类的子类来实现代理类**。需要注意final方法，final修饰的方法不可被继承



### 3、Java 中的注解原理是什么？

**注解本质上是种标记**，通过注解**可以给代码添加元数据信息，被JVM读取**。这些注解可**以标记在类、方法、属性上面**。但这些注解并**不会影响代码的执行逻辑**，我们可以使用工具/框架提供的注解处理器提取注解中的元数据，从而对这些元数据进行处理，可以是编译时/运行时/代码生成时

Java中的元注解有四类：

- @Retention：注解何时生效（编译/运行/源文件）
- @Inherited：注解能否被继承
- @Target：注解的作用目标
- @Document：是否包含在javadoc中



### 4、你使用过 Java 的反射机制吗？如何应用反射？

一般在我们使用的Spring框架中就有应用到反射机制，其中动态代理以及AOP都有用到反射机制。

反射机制是指在程序的运行中，可以**通过反射机制动态的获取类的成员方法和属性变量，以及类的构造方法等**。反射的**核心类是Class类**，每个类都有Class类通过该类可以获取类相关信息。除此之外还有**Method类、Field类**。获取Class对象有四种种方法：

- 类.Class 调用Class对象
- 类.getClass()方法 获取Class对象
- Class.forName(类的全路径)
- 类加载器.loadClass(类全称)







## **Java锁**

### 1、Java有哪些锁？

synchronized锁

ReentrantLock锁



### 2、什么是乐观锁、悲观锁？两者有什么区别？底层是如何实现的？

- 乐观锁：乐观认为读多写少，默认不加锁。通常在数据库添加flag标识，需要写时，检查flag是否一致，再对操作上锁
- 悲观锁：认为写多， 默认加锁。性能开销较大，安全性较高



### 3、什么是公平锁？什么是非公平锁？它们各有什么优缺点？

- **公平锁**：锁的资源的分配是公平的。优点就是**公平**，缺点**不够灵活**
- **非公平锁**：**随机分配**资源或者**就近分配**。实际用得多，因为灵活分配，**性能比公平锁的效率高不少**。



### 4、ReentrantLock和synchronized的区别是什么？5

- 用法：**Re**用于代码块，**sy**用于方法、代码块
- 获取方式：**Re**需要手动获取释放，sy自动
- 锁的类型：**Re**可以是公平/非公平锁，sy是非公平锁
- 响应中断：**Re**可以获取锁并响应中断，sy不能，会死锁
- 底层实现：Re是AQS实现，**sy**是监视器实现

|              | ReentrantLock | synchronized |
| ------------ | ------------- | ------------ |
| **用法**     | 代码块        | 方法、代码块 |
| **获取方式** | 手动          | 自动         |
| **锁的类型** | 公平/非公平锁 | 非公平锁     |
| **响应中断** | 可以          | 不能，会死锁 |
| **底层实现** | AQS           | 监视器       |

*AQS是构造 锁和同步器的框架*



## **JVM**

### 1、JVM描述JVM的内存模型

方法区（元空间）、堆、本地方法栈、虚拟机栈、程序计数器

- **方法区（元空间）：**线程共享。**常量、静态变量、类信息**
- **堆：**所有线程共享。**对象实例**，内存分配和垃圾回收的重点区域
- **本地方法栈：**线程私有，虚拟机使用到的**本地（Native）方法**服务
- **虚拟机栈：**线程私有，存储局部**变量表**、**操作数栈**、动态链接、**方法出口**等信息
- **程序计数器：**存储正在执行的虚拟机**指令的地址**。



### 2、什么是GC（垃圾回收）

虚拟机在运行时，创建对象需要分配内存空间。内存空间是有限的，当创建的对象不需要时，内存需要得到释放。CG垃圾回收就可以帮助程序员自动释放内存。



### 3、常见的GC算法有哪些？4

- **标记清除法**：标记被使用的内存，清理没有被引用的内存。
- **复制算法**：将内存分为两块区域，一次只用一块，将被标记的内存移动到另一块，清空原来那块。
- **标记整理法**：将被标记的内存向一边对齐整理，然后清除另一边内存。
- **分代收集算法**：将内存空间分为新生代、老年代、永生带三块。不同区域使用不同算法，根据对象寿命将它们放在不同的内存中



### 4、如何排查和解决JVM内存泄漏问题？

**排查**：**监控内存使用情况**，如果内存使用持续增长，垃圾回收频繁且回收效果不佳，或者出现 `OutOfMemoryError` 异常

**解决**：确保资源在使用后正确关闭，**优化缓存和连接池策略**



### 5、如何判断哪些内存需要回收？2

- **可达性分析**：从GC Roots对象开始，根据对象的引用关系搜索
- **引用计数法**：根据内存被引用的次数判断



## IO、File、Stream

1、



# Spring



## **Spring** 

### 1、什么是Spring？

一个为解决企业开发问题的，Java轻量级开发框架，解决企业开发的复杂性。

核心特点是IOC控制反转、AOP面向切面编程



### 2、什么是 Spring IOC？

**控制反转**。即**类与类之间的依赖关系交给Spring容器去控制、配置实现**，通过注解的方式，创建对象时，在程序运行中，动态的将需要的依赖注入到类中。由**容器根据配置文件去创建实例并管理**各个实例之间的依赖关系

优势：降低了代码的耦合性，提高了代码的复用性，增强了类的拓展性



### 3、Spring 框架中都用到了哪些设计模式？

- 单例模式：IOC容器中的bean都是单例的
- 工厂模式：Spring 使用工厂模式通过 `BeanFactory`、`ApplicationContext` 创建 bean 对象
- 代理模式：AOP功能实现
- 模板方法模式 ：对数据库操作中Template结尾的库使用了模版方法
- 适配器模式：Spring AOP 的增强或通知(Advice)使用到了适配器模式。spring MVC 中也是用到了适配器模式适配`Controller`



### 4、Spring 包含的模块有哪些？

Spring DA、 Spring Web(包括了SpringMVC)、Spring AOP、Spring core container核心容器



### 6、谈谈自己对于 Spring IoC 的了解

IOC就是控制反转，意思就是将我们平常自己创建的类的**声明**和**实例化对象**交给Spring容器去管理。当我们需要这些对象时，我们可以通过DI依赖注入的方式获取到这些对象。



### 7、什么是 Spring Bean？

交给Spring IOC容器管理的对象都可以称之为Bean



### 8、将一个类声明为 Bean 的注解有哪些?

- @Component：用于声明Bean的通用注解，标注任意类为 `Spring` 组件
- @Controller：声明控制层的Bean的注解，与用户端的数据交互（@RestController，`@RestController` 注解代替传统的 `@Controller` 注解，这样所有方法默认会返回 JSON 格式的数据，而不是试图解析视图。）
- @Service：声明业务层的Bean的注解，定义逻辑业务的方法
- @Repository/@Mapper：声明数据持久层的Bean的注解，负责对数据的查询和处理等操作



### 9、@Component 和 @Bean 的区别是什么？

**@Component**注解用于类上，通过**类路径扫描**寻找并装配注解的类，一般使用**@ComponentScan**注解定义需要扫描的路径

**@Bean**注解用于方法之上，如果@Bean所在的类是**@Configuration配置类，会被Spring自动发现**，否则需要使用@ComponentScan或**@import**显式导入



### 10、注入bean的注解有哪些？

**@Autowired**、@Resource、@Inject。



### 11、**@Autowired**、@Resource两者有什么区别？

@Autowired是Spring提供的，默认注入方式为**byType**，并且`@Autowired` 支持在**构造函数**和**参数**使用

@Resource是JDK提供的，默认注入为**byName**



### 12、注入bean的方式有哪些？

- 字段注入：使用@Autowired / @Resource注解
- Setter方法注入：调用类的Setter方法
- **构造函数注入：使用构造函数注入（官方推荐）**结合`@RequiredArgsConstructor`使用



### 13、构造函数注入还是Setter注入？

构造函数。

这种注入方式能够保证

**依赖完整性**（确保所有的依赖在创建时就已经注入），

**不可变性**（注入对象不可被修改，确保线程安全），

<u>**初始化保证**（组件在使用前确保被初始化）。</u>

Setter注入适合用于可选的依赖项bean。



### 14、Bean的作用域有哪些？

1. singleton单例模式：Ioc容器中只会存在一个唯一的bean的实例化对象
2. prototype多例模式：每次获取bean对象都是一个新的bean实例
3. <u>request请求模式：对于每个http请求，会产生一个新的bean</u>
4. session会话模式：对于每个会话，会产生一个新的bean
5. globa session全局会话模式：对于整个web应用，启动时会产生一个新的bean，该 bean 仅在当前应用启动时间内有效。
6. webSocket：对于一个WebSocket，会产生一个新的bean



### 15、Bean 是线程安全的吗？

看情况。

大多数情况是singleton模式，会存在线程安全问题。为了避免，建议都**使用无状态的bean**。实在需要的话，使用**synchronized和ReentrantLock**实现线程安全。将可变变量**存储在ThreadLocal**中，该变量每个线程只有一个。

多例模式下，每个http都会有bean，没有线程安全问题。



### **16、Bean 的生命周期了解么?**

1. **实例化**、**创建bean实例**
2. **赋值、设置属性**
3. **初始化**，该过程包括了**检查Aware接口**以及设置相关依赖、执行初始化前后置方法、初始化Init方法、**InitializingBean**接口。
4. **销毁**，<u>过程包括了**注册Destruction相关回调接口**，**使用完后**、检查**DisposableBean**接口、以及销毁destroy方法</u>



<img src="./images/Spring生命周期.png" alt="Spring的生命周期" style="zoom:12%;" />





## **Spring AOP**

### 1、谈谈自己对于 AOP 的了解

AOP就是**面向切面编程**，将跟主业务无关的代码抽离出成**切面**，例如**事务管理、日志记录、权限管理**等。抽离出的代码称之为**通知**，当程序执行到注解标记的**切入点**时，系统会执行通知，实现面向切面编程。这样做的好处就是**提高代码的复用性，降低耦合**，**分离**与主业务无关代码。



### 2、AOP 常见的通知类型有哪些？

1. 前置通知
2. 后置通知
3. 环绕通知：直接拿到目标对象，以及要执行的方法。编程式控制目标对象的方法调用
4. 异常通知：抛出异常后触发
5. <u>返回通知：返回结果前触发</u>



### 3、多个切面的执行顺序如何控制？

- @Order注解
- 实现Order接口并**重写getOrder方法**



### 4、AOP的使用场景有哪些？

- 缓存管理
- 事务管理
- 日志记录
- 性能监控
- 权限控制、数据验证





## **SpringMVC**

### 1、Spring,Spring MVC,Spring Boot 之间什么关系?

Spirng是Spring framework的简称，包括了许多组件和库，是一个轻量的企业级开发框架。而SpringMVC是Spring的一个功能模块，提供了快速构建Web应用的途径。SpringBoot是对Spring框架的简化，提供了许多注解简化了SpringXML配置文件的编写。



### 4、说说自己对于 Spring MVC 了解?

MVC是一种软件架构的设计模式。将一个Web应用分为模型M、视图V、控制器三个层面，将不同的模块分离解耦。

SpringMVC是一个框架，可以帮助我们更快的进行Web应用开发，在MVC架构下一般将系统分为：控制层、数据层、业务层、实体层。



### 5、Spring MVC 的核心组件有哪些？

1. DispatchServlet：核心处理器
2. HandleMapping：处理映射器
3. HandleAdapter：处理适配器
4. Handle：请求处理器
5. ViewResolver：视图解析器



### 6、SpringMVC 工作原理了解吗?

JSP开发

首先是DispatchServlet拿到Http请求，将Http请求交给HandleMapping之后，寻找相应的Handle处理器。再将拦截的请求和Handle交给HandleAdapter进行处理，处理完成后的结果返回给DispatchServlet。DispatchServlet将结果交给ViewResolve进行解析渲染。



### 7、统一异常处理怎么做？

1、实现HandlerExceptionResolver接口

2、@ExceptionHandler

**3、@ControllerAdvice+@ExceptionHandler**

推荐使用注解，**@ControllerAdvice**和**@ExceptionHandler**

```Java
@ControllerAdvice //注解
@ResponseBody
public class GlobalExceptionHandler {

    @ExceptionHandler(BaseException.class)
    public ResponseEntity<?> handleAppException(BaseException ex, HttpServletRequest request) {
      //......
    }

    @ExceptionHandler(value = ResourceNotFoundException.class)
    public ResponseEntity<ErrorReponse> handleResourceNotFoundException(ResourceNotFoundException ex, HttpServletRequest request) {
      //......
    }
}
```
}



### ***8、Spring的IOC和AOP的实现原理是什么？**

IOC：Spring配置文件/注解和Java的反射机制

AOP：动态代理









## **Spring事务**

### 1、什么是事务？

一系列操作的集合，要么全部执行，要么全部不执行



### 2、事务的特性（ACID）了解么?

**原子性**Atomic：指事务不可拆分，要么全部执行要么不执行

**一致性**Consistency：事务执行前后都必须处于**一致的状态**

**隔离性**Isolation：并发时，一个事务不会被其他的事务所干扰。

**持久性**Duration：事务提交后，数据库会被永久的改变，即使系统故障。

原子性、隔离性、持久性都是为实现了事务的一致性。



### **3、Spring 管理事务的方式有几种？**

编程式：通过 `TransactionTemplate`或者`TransactionManager`手动管理事务

**声明式：使用`@Transactional`注管理事务**



### **4、事务传播是什么？**

事务传播行为是为了**解决业务层方法之间互相调用的事务问题**，处理多个事务之间的关系



### 5、Spring 事务中哪几种事务传播行为?

1. 默认（加入）：没有事务则创建，有事务则加入
2. 挂起：当前存在事务，则将当前事务挂起
3. 嵌套：创建一个事务座位当前事务的嵌套事务执行
4. 强制加入：当前存在事务，则加入；不存在事务，则抛出异常



### 6、Spring 事务中的隔离级别有哪几种?

1. default：默认级别（committed）
2. **读未提交uncommitted**：可读取未提交的数据变更
3. **读已提交committed：可读取已提交的数据变更**
4. **可重复读repeatable**：对同一字段的读取结果是相同的
5. **串行化serializable**：完全遵循ACID操作，性能开销较大



### 7、@Transactional(rollbackFor = Exception.class)注解了解吗？

这个注解是声明式管理事务。用在需要添加事务的方法上，其中rollbackfor属性用于指定**回滚规则**发生Exception异常时进行事务回滚。



### 8、事务属性有哪些？+

1.  回滚规则
2.  隔离级别
3.  传播行为
4.  是否只读
5.  <u>事务超时</u>



## **常用接口**

### @CommandLineRunner

 Spring Boot 中的一个接口，用于在应用启动完成后执行命令行风格的运行逻辑。实现了这个接口的类会在Spring应用启动后自动运行其`run`方法，通常用于执行一些初始化任务或简单的命令行操作。



### **@ApplicationListener** 

Spring 框架中的一个接口，用于监听 Spring 应用上下文中发布的事件。实现了这个接口的类可以订阅特定类型的事件，并在事件发生时执行相应的处理逻辑。

#### 特点

- **事件驱动**：基于观察者模式，允许应用在发生特定事件时通知相关的监听器。
- **灵活定制**：可以监听 Spring 自带的事件，也可以定义自己的事件类型。
- **非阻塞**：事件的发布和监听是异步的，不会阻塞应用的正常运行流程。

#### 使用场景

- **应用启动完成后执行操作**：监听`ApplicationReadyEvent`，在应用完全启动后执行一些初始化或设置任务。
- **应用关闭前清理资源**：监听`ContextClosedEvent`，在应用关闭前释放资源或执行清理工作。
- **自定义事件处理**：定义自己的事件类型，用于在应用的不同模块之间传递信息或触发特定操作。



### @RestController

 `@Controller` 和 `@ResponseBody` 的**组合注解**

`@Controller` 注解**标记**一个类为**控制器，**

`@ResponseBody` 注解然后在每个方法上使用它来**将方法的返回值作为 HTTP 响应体返回。**

而 `@RestController` 注解直接将这两个功能合并，省去了重复的 `@ResponseBody` 注解。



### @Component

用于标识一个类为Spring组件



### @ComponentScan

指定@Component的类扫描路径



### @Transactional

声明式的事务注解，基于AOP实现。用于标识需要进行事务管理的方法。









# **Redis**

### 1、缓存穿透、缓存击穿、缓存雪崩是什么？

- 穿透：请求的数据在缓存中不存在，直接访问数据库
- 击穿：热点数据失效，导致大量请求发送到数据库
- 雪崩：同一时间大量缓存失效



### 2、解决方法？

**穿透：**

- 布隆过滤器
- 缓存空值

**击穿：**

- 互斥锁（单线程）
- 双层缓存

**雪崩：**

- 随机过期时间
- 多级缓存



### 3、Redis的使用场景 

- 缓存
- 分布式锁
- 消息队列
- 计数器
- 数据发布 / 订阅



### <u>**4、描述缓存的使用场景及其实现方式（Redis）。**-</u>

使用场景：

1. 提高数据读取速度
2. 减轻数据库的负载
3. 高并发下限流、热点数据保护（缓存数据库）
4. 分布式会话管理（分布式锁）
5. 数据预热、异步加载（消息队列）

实现方式：

- 1.2.3 **缓存**
  - 缓存更新策略
    - 写直达：更新数据同时更新缓存和数据库
    - 读-写：读取先访问缓存，没有则访问数据库，并将数据写入数据库。写只更新数据库
    - **缓存-aside**：先读取缓存再访问数据库，更新数据后，删除缓存并重新写入
- 4.**分布式锁**
- 5.**消息队列**



### 5、Redis中存储的数据类型有哪些？

- 字符串
- 列表
- 哈希表
- 集合
- 有序集合



### <u>6、如何保证缓存与数据库最终一致性</u>





# Mybatis

### 1、#{}和${}有什么区别

**#{}：预编译处理**，使用？代替#{}，调用set方法赋值，可以有效**防止字段注入**

**${}：字符串替换**，将${}替换为字符串的值。







# **消息队列**

### 1、什么是MQ？

应用程序间的通讯方式，实现组件之间的异步消息传输。生产者发送消息到消息队列，消费者在消息队列中拉取消息处理，两者不需要同时交互。



### 2、MQ消息堆积如何处理？+

- **生产者：**
  - 限流
  - 批量发送
  - 消息去重
  - 优化重发机制
- **存储端（消息队列）**：
  - 调整超时策略
  - 提高存储性能
  - 提高IO性能
- **消费者：**
  - 调整拉取策略
  - 提高处理并发量
  - 提升处理性能 / 增加消费者数量
  - **优化处理逻辑**



# **设计模式**

**创建型模式**：

- 单例
- 工厂
- 抽象工厂
- 建造者
- 原型

**结构型模式：**

- 代理
- 外观
- 桥接
- 组合
- 享元
- 适配器
- 装饰器

**行为型模式：**

- 策略
- 命令
- 责任链
- 迭代器
- 观察者
- 中介者
- 访问者
- 模版方法
- 模式状态



## 1、单例模式

创建型模式。一个类只有一个实例，使用时不需要再实例化，提供全局访问点。用于解决一个全局使用的类的重复创建与销毁

优点：只存在一个实例化减少了内存的开销，避免重复创建实例。同时避免了资源的重复占用

缺点：没有接口，不能继承，违背单一职责原则。不关注外部如何实例化

### 1-1、实现方式有哪些？

- **懒汉式**：延迟加载，第一次获取实例再创建。

  - 优点：不过多占用资源
  - 缺点：线程不安全，实现需要使用sychronized

  ```Java
  1.首先，将构造函数私有化
  private() Singleton { }
  2.然后，声明一个静态的类实例，初始时为 null：
  private static Singleton instance = null;
  3.最后，提供一个公有的静态方法来获取实例，当第一次调用该方法时创建实例。
  public static Singleton getInstance()
  {
      if (instance == null)
      {
          instance = new Singleton();
      }
      return instance;
  }
  ```

- **饿汉式**：类加载时就创建实例。

  - 优点：线程安全
  - 缺点：没有延迟加载，会造成资源浪费

  ```java
  将函数构造私有化：
      private Singleton() { }
  在类的内部直接创建实例：
      private static Singleton instance = new Singleton();
  提供一个公有的静态方法来获取实例：
      public static Singleton getInstance() { return instance; }
  ```

- **双重校验锁机制（推荐）**：在懒汉式的基础上，静态实例用**volatile**修饰，内嵌一个判断并使用**sychronized**加锁

  ```java
  首先，将构造函数私有化：
      private Singleton() { }
  声明一个 volatile 的静态实例变量：
      private static volatile Singleton instance = null;
  提供一个公有的静态方法来获取实例：
  public static Singleton getInstance()
  {
      if (instance == null)
      {
          synchronized (Singleton.class)
          {
              if (instance == null)
              {
                  instance = new Singleton();
              }
          }
      }
      return instance;
  }
  ```

- **静态内部类（推荐）**：利用了 **Java 的类加载机制**来实现线程安全的单例

  ```java
  * 这种方式利用了 Java 的类加载机制来实现线程安全的单例。它的实现代码如下：
  * 1.将构造函数私有化：
      private Singleton() { }
  * 2.创建一个静态内部类，在这个内部类中创建实例：
  * private static class SingletonHolder
  * {
  *     private static final Singleton INSTANCE = new Singleton();
  * }
  * 3.提供一个公有的静态方法来获取实例：
      public static Singleton getInstance() { return SingletonHolder.INSTANCE; }
  ```



### 1-2、单例有哪些应用？

线程池、数据库连接池、缓存系统、配置管理类、日志系统



## 2、策略模式

### 1、什么是策略模式？

行为模式的一种。将不同的算法封装成策略类，程序运行时，根据实际情况可以将算法替换，将算法独立于原来的代码。

- **接口实现**：

  1. 定义策略接口
  2. 定义策略类实现策略接口
  3. 创建策略上下文类，封装策略对象和调用逻辑，通过该类使用不同的策略

- **继承实现：**将顶层接口换为抽象类，但不够灵活。

- **策略工厂实现**：

  ```java
  当策略种类很多时，可以创建一个策略工厂来管理策略对象的创建。例如，定义一个支付策略工厂：
  public class PaymentStrategyFactory {
      public static PaymentStrategy getPaymentStrategy(String paymentType) {
          switch (paymentType.toLowerCase()) {
              case "creditcard":
                  // 返回信用卡支付策略对象
                  return new CreditCardPayment("card123", "date123");
              case "paypal":
                  // 返回 PayPal 支付策略对象
                  return new PayPalPayment("email@paypal.com", "password123");
              // 其他支付方式
              default:
                  throw new IllegalArgumentException("Invalid payment type");
          }
      }
  }
  ```

- **结合函数式接口（Java 8 及以上版本）实现**





# 分布式

### 1、CAP理论是什么？

指一个分布式系统中C一致性、A可用性、P分区容错性三者只能同时满足两个。

- C（Consistency）：**一致性**，所有分布式节点访问相同数据，返回的结果一致最新的写入结果
- A（Availability）：**可用性，**发出的请求在一定时间内无论如何都会获得一个响应
- P（Partition Tolerance）：**分区容错性**，网络节点通信失效，系统也能继续运行

一般分为CP、AP。网络分区不可避免，对于数据一致要求高的使用CP模型，如金融；对于可用性要求高的用AP，社交媒体。



# **性能优化**

### 1、代码优化如何优化Java中的字符串拼接操作？

- 使用**StringBuffer / Stringbuilder类**，减少创建String开销
- 使用 **+ 运算符**，底层通过StringBuilder的append方法实现
- 使用**String.join**方法拼接，也是使用StringBuilder实现



### 2、如何设计一个高可用的分布式系统？+

- **系统架构**
  - **服务拆分，模块化**：拆分为独立模块避免整体崩溃
  - **分布式架构**：微服务架构、服务网格架构解耦系统
- **冗余设计**
  - **服务器冗余：**多地部署服务器和数据中心，若故障可由其他服务器和数据中心接管
  - **数据库冗余：**主从数据库设计，面对故障快速切换数据源
- **负载均衡**
  - **网络负载均衡：**分配请求至不同的服务器处理
  - **应用处理负载均衡：**微服务架构下，服务之间调用时负载均衡
- **故障转移、恢复机制**
  - **故障转移：**当某一节点发生故障时，系统自动触发故障转移，将请求切换到备用服务器
  - **恢复机制：**建立备份系统，定期备份系统数据。故障发生时从备份中快速恢复
- **可靠通信**
  - **消息队列：**引入MQ中间件缓冲消息，保证可靠传递
  - **可靠协议：**使用TCP等可靠协议
- **性能监控**
- **定期测试**



### 3、系统优化如何优化数据库查询性能？+

- 索引优化
  - 创建合理的索引
  - 减少索引的数量
- 查询语句优化
  - 减少select *的使用
  - 减少模糊查询
  - 减少子查询
  - **使用合理的连接查询**
- 表结构优化
  - 使用合适的数据类型
  - 表分区
  - 表归一化和反归一化（数据冗余和冗余表）
- 查询缓存
- 数据库性能优化
  - 优化内存分配
  - IO优化
  - **优化连接池策略**
- **分布式数据库**
  - **分片策略**
  - **减少分布式事务**





# 算法

### 排序

#### 1、快速排序（Quick Sort）

#### 2、归并排序**（Merge Sort）**

#### 3、插入排序（Insertion Sort）



### 字符串

#### 1、判断一个字符串是否是回文

- 双指针
  - 定义两个指针，分别从头尾开始依次向中间靠拢比较
- 字符串反转

#### 2、给定26个字母，如何快速获取所有的组合



### 数组

#### 1、整数数组，求出最长的连续增长数组，时间复杂度为On

#### 2、求数组指定范围内的和（区间和）

#### 3、长度最小的子数组

#### 4、给定有序数组，求每个元素平方后的有序数组

#### 5、



### 链表

#### 1、单链表，删除倒数第n个元素，要求On

- **双指针：**
  1. 快指针提前走n-1步
  2. 快慢指针同步向前走，直到快指针为null
  3. 慢指针.next即为倒数第n个元素

#### 2、判断链表中有环，并返回环的入口

- **快慢指针**：
  - 思路：不同速度在环内奔跑总会相遇，二者的总行程为 2\*(x+y) = x+y+n*(y+z)，，当n=1时，可计算出x的距离
    1. 定义快慢指针slow、fast，fast移动速度为slow的两倍，依次向前移动
    2. 当slow == fast时，即证明链表中有环
    3. 两指针相遇后，令fast返回链表起点，并且速度与slow相同
    4. 当再次slow == fast后，即为环的入口

#### 3、判断两链表是否相交，返回交点

- **哈希表**：
  1. 将链表1中所有的ListNode放入哈希表中
  2. 依次遍历链表2，判断是否存在于哈希表中
  3. 第一个出现在哈希表中的元素即为交点
- **快慢指针**： 链表后半段长度相等，让快指针提前走L1.length-L2.length步即可	
  1. 定义两个指针，分别向后移动，直至p1 == p2
  2. 若其中一个指针提前到达链表末尾，则令p指向另一个链表的头结点h
  3. 循环往复，若p1 == p2，则说明相交，该节点为交点。
  4. 若p1 == p2 == null，则说明没有交点

















# END